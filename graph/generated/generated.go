// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/memocash/index/graph/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
	Subscription() SubscriptionResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Block struct {
		Hash      func(childComplexity int) int
		Height    func(childComplexity int) int
		Raw       func(childComplexity int) int
		Size      func(childComplexity int) int
		Timestamp func(childComplexity int) int
		TxCount   func(childComplexity int) int
		Txs       func(childComplexity int, start *uint32) int
	}

	Follow struct {
		Address       func(childComplexity int) int
		FollowAddress func(childComplexity int) int
		FollowLock    func(childComplexity int) int
		Lock          func(childComplexity int) int
		Tx            func(childComplexity int) int
		TxHash        func(childComplexity int) int
		Unfollow      func(childComplexity int) int
	}

	Like struct {
		Address    func(childComplexity int) int
		Lock       func(childComplexity int) int
		Post       func(childComplexity int) int
		PostTxHash func(childComplexity int) int
		Tip        func(childComplexity int) int
		Tx         func(childComplexity int) int
		TxHash     func(childComplexity int) int
	}

	Lock struct {
		Address func(childComplexity int) int
		Profile func(childComplexity int) int
		Txs     func(childComplexity int, start *model.Date, tx *model.Hash) int
	}

	Mutation struct {
		Broadcast func(childComplexity int, raw string) int
	}

	Post struct {
		Address func(childComplexity int) int
		Likes   func(childComplexity int) int
		Lock    func(childComplexity int) int
		Parent  func(childComplexity int) int
		Replies func(childComplexity int) int
		Room    func(childComplexity int) int
		Text    func(childComplexity int) int
		Tx      func(childComplexity int) int
		TxHash  func(childComplexity int) int
	}

	Profile struct {
		Address   func(childComplexity int) int
		Followers func(childComplexity int, start *model.Date) int
		Following func(childComplexity int, start *model.Date) int
		Lock      func(childComplexity int) int
		Name      func(childComplexity int) int
		Pic       func(childComplexity int) int
		Posts     func(childComplexity int, start *model.Date, newest *bool) int
		Profile   func(childComplexity int) int
		Rooms     func(childComplexity int, start *model.Date) int
	}

	Query struct {
		Address     func(childComplexity int, address model.Address) int
		Addresses   func(childComplexity int, addresses []model.Address) int
		Block       func(childComplexity int, hash model.Hash) int
		BlockNewest func(childComplexity int) int
		Blocks      func(childComplexity int, newest *bool, start *uint32) int
		Posts       func(childComplexity int, txHashes []model.Hash) int
		PostsNewest func(childComplexity int, start *model.Date, tx *model.Hash, limit *uint32) int
		Profiles    func(childComplexity int, addresses []model.Address) int
		Room        func(childComplexity int, name string) int
		Tx          func(childComplexity int, hash model.Hash) int
		Txs         func(childComplexity int, hashes []model.Hash) int
	}

	Room struct {
		Followers func(childComplexity int, start *int) int
		Name      func(childComplexity int) int
		Posts     func(childComplexity int, start *int) int
	}

	RoomFollow struct {
		Address  func(childComplexity int) int
		Lock     func(childComplexity int) int
		Name     func(childComplexity int) int
		Room     func(childComplexity int) int
		Tx       func(childComplexity int) int
		TxHash   func(childComplexity int) int
		Unfollow func(childComplexity int) int
	}

	SetName struct {
		Address func(childComplexity int) int
		Lock    func(childComplexity int) int
		Name    func(childComplexity int) int
		Tx      func(childComplexity int) int
		TxHash  func(childComplexity int) int
	}

	SetPic struct {
		Address func(childComplexity int) int
		Lock    func(childComplexity int) int
		Pic     func(childComplexity int) int
		Tx      func(childComplexity int) int
		TxHash  func(childComplexity int) int
	}

	SetProfile struct {
		Address func(childComplexity int) int
		Lock    func(childComplexity int) int
		Text    func(childComplexity int) int
		Tx      func(childComplexity int) int
		TxHash  func(childComplexity int) int
	}

	SlpBaton struct {
		Genesis   func(childComplexity int) int
		Hash      func(childComplexity int) int
		Index     func(childComplexity int) int
		Output    func(childComplexity int) int
		TokenHash func(childComplexity int) int
	}

	SlpGenesis struct {
		Baton      func(childComplexity int) int
		BatonIndex func(childComplexity int) int
		Decimals   func(childComplexity int) int
		DocHash    func(childComplexity int) int
		DocURL     func(childComplexity int) int
		Hash       func(childComplexity int) int
		Name       func(childComplexity int) int
		Output     func(childComplexity int) int
		Ticker     func(childComplexity int) int
		TokenType  func(childComplexity int) int
		Tx         func(childComplexity int) int
	}

	SlpOutput struct {
		Amount    func(childComplexity int) int
		Genesis   func(childComplexity int) int
		Hash      func(childComplexity int) int
		Index     func(childComplexity int) int
		Output    func(childComplexity int) int
		TokenHash func(childComplexity int) int
	}

	Subscription struct {
		Address     func(childComplexity int, address model.Address) int
		Addresses   func(childComplexity int, addresses []model.Address) int
		Blocks      func(childComplexity int) int
		Posts       func(childComplexity int, hashes []model.Hash) int
		Profiles    func(childComplexity int, addresses []model.Address) int
		RoomFollows func(childComplexity int, addresses []model.Address) int
		Rooms       func(childComplexity int, names []string) int
	}

	Tx struct {
		Blocks   func(childComplexity int) int
		Hash     func(childComplexity int) int
		Inputs   func(childComplexity int) int
		LockTime func(childComplexity int) int
		Outputs  func(childComplexity int) int
		Raw      func(childComplexity int) int
		Seen     func(childComplexity int) int
		Version  func(childComplexity int) int
	}

	TxBlock struct {
		Block     func(childComplexity int) int
		BlockHash func(childComplexity int) int
		Index     func(childComplexity int) int
		Tx        func(childComplexity int) int
		TxHash    func(childComplexity int) int
	}

	TxInput struct {
		Hash      func(childComplexity int) int
		Index     func(childComplexity int) int
		Output    func(childComplexity int) int
		PrevHash  func(childComplexity int) int
		PrevIndex func(childComplexity int) int
		Script    func(childComplexity int) int
		Sequence  func(childComplexity int) int
		Tx        func(childComplexity int) int
	}

	TxOutput struct {
		Amount   func(childComplexity int) int
		Hash     func(childComplexity int) int
		Index    func(childComplexity int) int
		Lock     func(childComplexity int) int
		Script   func(childComplexity int) int
		Slp      func(childComplexity int) int
		SlpBaton func(childComplexity int) int
		Spends   func(childComplexity int) int
		Tx       func(childComplexity int) int
	}
}

type MutationResolver interface {
	Broadcast(ctx context.Context, raw string) (bool, error)
}
type QueryResolver interface {
	Tx(ctx context.Context, hash model.Hash) (*model.Tx, error)
	Txs(ctx context.Context, hashes []model.Hash) ([]*model.Tx, error)
	Address(ctx context.Context, address model.Address) (*model.Lock, error)
	Addresses(ctx context.Context, addresses []model.Address) ([]*model.Lock, error)
	Block(ctx context.Context, hash model.Hash) (*model.Block, error)
	BlockNewest(ctx context.Context) (*model.Block, error)
	Blocks(ctx context.Context, newest *bool, start *uint32) ([]*model.Block, error)
	Profiles(ctx context.Context, addresses []model.Address) ([]*model.Profile, error)
	Posts(ctx context.Context, txHashes []model.Hash) ([]*model.Post, error)
	PostsNewest(ctx context.Context, start *model.Date, tx *model.Hash, limit *uint32) ([]*model.Post, error)
	Room(ctx context.Context, name string) (*model.Room, error)
}
type SubscriptionResolver interface {
	Address(ctx context.Context, address model.Address) (<-chan *model.Tx, error)
	Addresses(ctx context.Context, addresses []model.Address) (<-chan *model.Tx, error)
	Blocks(ctx context.Context) (<-chan *model.Block, error)
	Posts(ctx context.Context, hashes []model.Hash) (<-chan *model.Post, error)
	Profiles(ctx context.Context, addresses []model.Address) (<-chan *model.Profile, error)
	Rooms(ctx context.Context, names []string) (<-chan *model.Post, error)
	RoomFollows(ctx context.Context, addresses []model.Address) (<-chan *model.RoomFollow, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Block.hash":
		if e.complexity.Block.Hash == nil {
			break
		}

		return e.complexity.Block.Hash(childComplexity), true

	case "Block.height":
		if e.complexity.Block.Height == nil {
			break
		}

		return e.complexity.Block.Height(childComplexity), true

	case "Block.raw":
		if e.complexity.Block.Raw == nil {
			break
		}

		return e.complexity.Block.Raw(childComplexity), true

	case "Block.size":
		if e.complexity.Block.Size == nil {
			break
		}

		return e.complexity.Block.Size(childComplexity), true

	case "Block.timestamp":
		if e.complexity.Block.Timestamp == nil {
			break
		}

		return e.complexity.Block.Timestamp(childComplexity), true

	case "Block.tx_count":
		if e.complexity.Block.TxCount == nil {
			break
		}

		return e.complexity.Block.TxCount(childComplexity), true

	case "Block.txs":
		if e.complexity.Block.Txs == nil {
			break
		}

		args, err := ec.field_Block_txs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Block.Txs(childComplexity, args["start"].(*uint32)), true

	case "Follow.address":
		if e.complexity.Follow.Address == nil {
			break
		}

		return e.complexity.Follow.Address(childComplexity), true

	case "Follow.follow_address":
		if e.complexity.Follow.FollowAddress == nil {
			break
		}

		return e.complexity.Follow.FollowAddress(childComplexity), true

	case "Follow.follow_lock":
		if e.complexity.Follow.FollowLock == nil {
			break
		}

		return e.complexity.Follow.FollowLock(childComplexity), true

	case "Follow.lock":
		if e.complexity.Follow.Lock == nil {
			break
		}

		return e.complexity.Follow.Lock(childComplexity), true

	case "Follow.tx":
		if e.complexity.Follow.Tx == nil {
			break
		}

		return e.complexity.Follow.Tx(childComplexity), true

	case "Follow.tx_hash":
		if e.complexity.Follow.TxHash == nil {
			break
		}

		return e.complexity.Follow.TxHash(childComplexity), true

	case "Follow.unfollow":
		if e.complexity.Follow.Unfollow == nil {
			break
		}

		return e.complexity.Follow.Unfollow(childComplexity), true

	case "Like.address":
		if e.complexity.Like.Address == nil {
			break
		}

		return e.complexity.Like.Address(childComplexity), true

	case "Like.lock":
		if e.complexity.Like.Lock == nil {
			break
		}

		return e.complexity.Like.Lock(childComplexity), true

	case "Like.post":
		if e.complexity.Like.Post == nil {
			break
		}

		return e.complexity.Like.Post(childComplexity), true

	case "Like.post_tx_hash":
		if e.complexity.Like.PostTxHash == nil {
			break
		}

		return e.complexity.Like.PostTxHash(childComplexity), true

	case "Like.tip":
		if e.complexity.Like.Tip == nil {
			break
		}

		return e.complexity.Like.Tip(childComplexity), true

	case "Like.tx":
		if e.complexity.Like.Tx == nil {
			break
		}

		return e.complexity.Like.Tx(childComplexity), true

	case "Like.tx_hash":
		if e.complexity.Like.TxHash == nil {
			break
		}

		return e.complexity.Like.TxHash(childComplexity), true

	case "Lock.address":
		if e.complexity.Lock.Address == nil {
			break
		}

		return e.complexity.Lock.Address(childComplexity), true

	case "Lock.profile":
		if e.complexity.Lock.Profile == nil {
			break
		}

		return e.complexity.Lock.Profile(childComplexity), true

	case "Lock.txs":
		if e.complexity.Lock.Txs == nil {
			break
		}

		args, err := ec.field_Lock_txs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Lock.Txs(childComplexity, args["start"].(*model.Date), args["tx"].(*model.Hash)), true

	case "Mutation.broadcast":
		if e.complexity.Mutation.Broadcast == nil {
			break
		}

		args, err := ec.field_Mutation_broadcast_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Broadcast(childComplexity, args["raw"].(string)), true

	case "Post.address":
		if e.complexity.Post.Address == nil {
			break
		}

		return e.complexity.Post.Address(childComplexity), true

	case "Post.likes":
		if e.complexity.Post.Likes == nil {
			break
		}

		return e.complexity.Post.Likes(childComplexity), true

	case "Post.lock":
		if e.complexity.Post.Lock == nil {
			break
		}

		return e.complexity.Post.Lock(childComplexity), true

	case "Post.parent":
		if e.complexity.Post.Parent == nil {
			break
		}

		return e.complexity.Post.Parent(childComplexity), true

	case "Post.replies":
		if e.complexity.Post.Replies == nil {
			break
		}

		return e.complexity.Post.Replies(childComplexity), true

	case "Post.room":
		if e.complexity.Post.Room == nil {
			break
		}

		return e.complexity.Post.Room(childComplexity), true

	case "Post.text":
		if e.complexity.Post.Text == nil {
			break
		}

		return e.complexity.Post.Text(childComplexity), true

	case "Post.tx":
		if e.complexity.Post.Tx == nil {
			break
		}

		return e.complexity.Post.Tx(childComplexity), true

	case "Post.tx_hash":
		if e.complexity.Post.TxHash == nil {
			break
		}

		return e.complexity.Post.TxHash(childComplexity), true

	case "Profile.address":
		if e.complexity.Profile.Address == nil {
			break
		}

		return e.complexity.Profile.Address(childComplexity), true

	case "Profile.followers":
		if e.complexity.Profile.Followers == nil {
			break
		}

		args, err := ec.field_Profile_followers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Profile.Followers(childComplexity, args["start"].(*model.Date)), true

	case "Profile.following":
		if e.complexity.Profile.Following == nil {
			break
		}

		args, err := ec.field_Profile_following_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Profile.Following(childComplexity, args["start"].(*model.Date)), true

	case "Profile.lock":
		if e.complexity.Profile.Lock == nil {
			break
		}

		return e.complexity.Profile.Lock(childComplexity), true

	case "Profile.name":
		if e.complexity.Profile.Name == nil {
			break
		}

		return e.complexity.Profile.Name(childComplexity), true

	case "Profile.pic":
		if e.complexity.Profile.Pic == nil {
			break
		}

		return e.complexity.Profile.Pic(childComplexity), true

	case "Profile.posts":
		if e.complexity.Profile.Posts == nil {
			break
		}

		args, err := ec.field_Profile_posts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Profile.Posts(childComplexity, args["start"].(*model.Date), args["newest"].(*bool)), true

	case "Profile.profile":
		if e.complexity.Profile.Profile == nil {
			break
		}

		return e.complexity.Profile.Profile(childComplexity), true

	case "Profile.rooms":
		if e.complexity.Profile.Rooms == nil {
			break
		}

		args, err := ec.field_Profile_rooms_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Profile.Rooms(childComplexity, args["start"].(*model.Date)), true

	case "Query.address":
		if e.complexity.Query.Address == nil {
			break
		}

		args, err := ec.field_Query_address_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Address(childComplexity, args["address"].(model.Address)), true

	case "Query.addresses":
		if e.complexity.Query.Addresses == nil {
			break
		}

		args, err := ec.field_Query_addresses_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Addresses(childComplexity, args["addresses"].([]model.Address)), true

	case "Query.block":
		if e.complexity.Query.Block == nil {
			break
		}

		args, err := ec.field_Query_block_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Block(childComplexity, args["hash"].(model.Hash)), true

	case "Query.block_newest":
		if e.complexity.Query.BlockNewest == nil {
			break
		}

		return e.complexity.Query.BlockNewest(childComplexity), true

	case "Query.blocks":
		if e.complexity.Query.Blocks == nil {
			break
		}

		args, err := ec.field_Query_blocks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Blocks(childComplexity, args["newest"].(*bool), args["start"].(*uint32)), true

	case "Query.posts":
		if e.complexity.Query.Posts == nil {
			break
		}

		args, err := ec.field_Query_posts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Posts(childComplexity, args["txHashes"].([]model.Hash)), true

	case "Query.posts_newest":
		if e.complexity.Query.PostsNewest == nil {
			break
		}

		args, err := ec.field_Query_posts_newest_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PostsNewest(childComplexity, args["start"].(*model.Date), args["tx"].(*model.Hash), args["limit"].(*uint32)), true

	case "Query.profiles":
		if e.complexity.Query.Profiles == nil {
			break
		}

		args, err := ec.field_Query_profiles_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Profiles(childComplexity, args["addresses"].([]model.Address)), true

	case "Query.room":
		if e.complexity.Query.Room == nil {
			break
		}

		args, err := ec.field_Query_room_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Room(childComplexity, args["name"].(string)), true

	case "Query.tx":
		if e.complexity.Query.Tx == nil {
			break
		}

		args, err := ec.field_Query_tx_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Tx(childComplexity, args["hash"].(model.Hash)), true

	case "Query.txs":
		if e.complexity.Query.Txs == nil {
			break
		}

		args, err := ec.field_Query_txs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Txs(childComplexity, args["hashes"].([]model.Hash)), true

	case "Room.followers":
		if e.complexity.Room.Followers == nil {
			break
		}

		args, err := ec.field_Room_followers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Room.Followers(childComplexity, args["start"].(*int)), true

	case "Room.name":
		if e.complexity.Room.Name == nil {
			break
		}

		return e.complexity.Room.Name(childComplexity), true

	case "Room.posts":
		if e.complexity.Room.Posts == nil {
			break
		}

		args, err := ec.field_Room_posts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Room.Posts(childComplexity, args["start"].(*int)), true

	case "RoomFollow.address":
		if e.complexity.RoomFollow.Address == nil {
			break
		}

		return e.complexity.RoomFollow.Address(childComplexity), true

	case "RoomFollow.lock":
		if e.complexity.RoomFollow.Lock == nil {
			break
		}

		return e.complexity.RoomFollow.Lock(childComplexity), true

	case "RoomFollow.name":
		if e.complexity.RoomFollow.Name == nil {
			break
		}

		return e.complexity.RoomFollow.Name(childComplexity), true

	case "RoomFollow.room":
		if e.complexity.RoomFollow.Room == nil {
			break
		}

		return e.complexity.RoomFollow.Room(childComplexity), true

	case "RoomFollow.tx":
		if e.complexity.RoomFollow.Tx == nil {
			break
		}

		return e.complexity.RoomFollow.Tx(childComplexity), true

	case "RoomFollow.tx_hash":
		if e.complexity.RoomFollow.TxHash == nil {
			break
		}

		return e.complexity.RoomFollow.TxHash(childComplexity), true

	case "RoomFollow.unfollow":
		if e.complexity.RoomFollow.Unfollow == nil {
			break
		}

		return e.complexity.RoomFollow.Unfollow(childComplexity), true

	case "SetName.address":
		if e.complexity.SetName.Address == nil {
			break
		}

		return e.complexity.SetName.Address(childComplexity), true

	case "SetName.lock":
		if e.complexity.SetName.Lock == nil {
			break
		}

		return e.complexity.SetName.Lock(childComplexity), true

	case "SetName.name":
		if e.complexity.SetName.Name == nil {
			break
		}

		return e.complexity.SetName.Name(childComplexity), true

	case "SetName.tx":
		if e.complexity.SetName.Tx == nil {
			break
		}

		return e.complexity.SetName.Tx(childComplexity), true

	case "SetName.tx_hash":
		if e.complexity.SetName.TxHash == nil {
			break
		}

		return e.complexity.SetName.TxHash(childComplexity), true

	case "SetPic.address":
		if e.complexity.SetPic.Address == nil {
			break
		}

		return e.complexity.SetPic.Address(childComplexity), true

	case "SetPic.lock":
		if e.complexity.SetPic.Lock == nil {
			break
		}

		return e.complexity.SetPic.Lock(childComplexity), true

	case "SetPic.pic":
		if e.complexity.SetPic.Pic == nil {
			break
		}

		return e.complexity.SetPic.Pic(childComplexity), true

	case "SetPic.tx":
		if e.complexity.SetPic.Tx == nil {
			break
		}

		return e.complexity.SetPic.Tx(childComplexity), true

	case "SetPic.tx_hash":
		if e.complexity.SetPic.TxHash == nil {
			break
		}

		return e.complexity.SetPic.TxHash(childComplexity), true

	case "SetProfile.address":
		if e.complexity.SetProfile.Address == nil {
			break
		}

		return e.complexity.SetProfile.Address(childComplexity), true

	case "SetProfile.lock":
		if e.complexity.SetProfile.Lock == nil {
			break
		}

		return e.complexity.SetProfile.Lock(childComplexity), true

	case "SetProfile.text":
		if e.complexity.SetProfile.Text == nil {
			break
		}

		return e.complexity.SetProfile.Text(childComplexity), true

	case "SetProfile.tx":
		if e.complexity.SetProfile.Tx == nil {
			break
		}

		return e.complexity.SetProfile.Tx(childComplexity), true

	case "SetProfile.tx_hash":
		if e.complexity.SetProfile.TxHash == nil {
			break
		}

		return e.complexity.SetProfile.TxHash(childComplexity), true

	case "SlpBaton.genesis":
		if e.complexity.SlpBaton.Genesis == nil {
			break
		}

		return e.complexity.SlpBaton.Genesis(childComplexity), true

	case "SlpBaton.hash":
		if e.complexity.SlpBaton.Hash == nil {
			break
		}

		return e.complexity.SlpBaton.Hash(childComplexity), true

	case "SlpBaton.index":
		if e.complexity.SlpBaton.Index == nil {
			break
		}

		return e.complexity.SlpBaton.Index(childComplexity), true

	case "SlpBaton.output":
		if e.complexity.SlpBaton.Output == nil {
			break
		}

		return e.complexity.SlpBaton.Output(childComplexity), true

	case "SlpBaton.token_hash":
		if e.complexity.SlpBaton.TokenHash == nil {
			break
		}

		return e.complexity.SlpBaton.TokenHash(childComplexity), true

	case "SlpGenesis.baton":
		if e.complexity.SlpGenesis.Baton == nil {
			break
		}

		return e.complexity.SlpGenesis.Baton(childComplexity), true

	case "SlpGenesis.baton_index":
		if e.complexity.SlpGenesis.BatonIndex == nil {
			break
		}

		return e.complexity.SlpGenesis.BatonIndex(childComplexity), true

	case "SlpGenesis.decimals":
		if e.complexity.SlpGenesis.Decimals == nil {
			break
		}

		return e.complexity.SlpGenesis.Decimals(childComplexity), true

	case "SlpGenesis.doc_hash":
		if e.complexity.SlpGenesis.DocHash == nil {
			break
		}

		return e.complexity.SlpGenesis.DocHash(childComplexity), true

	case "SlpGenesis.doc_url":
		if e.complexity.SlpGenesis.DocURL == nil {
			break
		}

		return e.complexity.SlpGenesis.DocURL(childComplexity), true

	case "SlpGenesis.hash":
		if e.complexity.SlpGenesis.Hash == nil {
			break
		}

		return e.complexity.SlpGenesis.Hash(childComplexity), true

	case "SlpGenesis.name":
		if e.complexity.SlpGenesis.Name == nil {
			break
		}

		return e.complexity.SlpGenesis.Name(childComplexity), true

	case "SlpGenesis.output":
		if e.complexity.SlpGenesis.Output == nil {
			break
		}

		return e.complexity.SlpGenesis.Output(childComplexity), true

	case "SlpGenesis.ticker":
		if e.complexity.SlpGenesis.Ticker == nil {
			break
		}

		return e.complexity.SlpGenesis.Ticker(childComplexity), true

	case "SlpGenesis.token_type":
		if e.complexity.SlpGenesis.TokenType == nil {
			break
		}

		return e.complexity.SlpGenesis.TokenType(childComplexity), true

	case "SlpGenesis.tx":
		if e.complexity.SlpGenesis.Tx == nil {
			break
		}

		return e.complexity.SlpGenesis.Tx(childComplexity), true

	case "SlpOutput.amount":
		if e.complexity.SlpOutput.Amount == nil {
			break
		}

		return e.complexity.SlpOutput.Amount(childComplexity), true

	case "SlpOutput.genesis":
		if e.complexity.SlpOutput.Genesis == nil {
			break
		}

		return e.complexity.SlpOutput.Genesis(childComplexity), true

	case "SlpOutput.hash":
		if e.complexity.SlpOutput.Hash == nil {
			break
		}

		return e.complexity.SlpOutput.Hash(childComplexity), true

	case "SlpOutput.index":
		if e.complexity.SlpOutput.Index == nil {
			break
		}

		return e.complexity.SlpOutput.Index(childComplexity), true

	case "SlpOutput.output":
		if e.complexity.SlpOutput.Output == nil {
			break
		}

		return e.complexity.SlpOutput.Output(childComplexity), true

	case "SlpOutput.token_hash":
		if e.complexity.SlpOutput.TokenHash == nil {
			break
		}

		return e.complexity.SlpOutput.TokenHash(childComplexity), true

	case "Subscription.address":
		if e.complexity.Subscription.Address == nil {
			break
		}

		args, err := ec.field_Subscription_address_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.Address(childComplexity, args["address"].(model.Address)), true

	case "Subscription.addresses":
		if e.complexity.Subscription.Addresses == nil {
			break
		}

		args, err := ec.field_Subscription_addresses_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.Addresses(childComplexity, args["addresses"].([]model.Address)), true

	case "Subscription.blocks":
		if e.complexity.Subscription.Blocks == nil {
			break
		}

		return e.complexity.Subscription.Blocks(childComplexity), true

	case "Subscription.posts":
		if e.complexity.Subscription.Posts == nil {
			break
		}

		args, err := ec.field_Subscription_posts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.Posts(childComplexity, args["hashes"].([]model.Hash)), true

	case "Subscription.profiles":
		if e.complexity.Subscription.Profiles == nil {
			break
		}

		args, err := ec.field_Subscription_profiles_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.Profiles(childComplexity, args["addresses"].([]model.Address)), true

	case "Subscription.room_follows":
		if e.complexity.Subscription.RoomFollows == nil {
			break
		}

		args, err := ec.field_Subscription_room_follows_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.RoomFollows(childComplexity, args["addresses"].([]model.Address)), true

	case "Subscription.rooms":
		if e.complexity.Subscription.Rooms == nil {
			break
		}

		args, err := ec.field_Subscription_rooms_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Subscription.Rooms(childComplexity, args["names"].([]string)), true

	case "Tx.blocks":
		if e.complexity.Tx.Blocks == nil {
			break
		}

		return e.complexity.Tx.Blocks(childComplexity), true

	case "Tx.hash":
		if e.complexity.Tx.Hash == nil {
			break
		}

		return e.complexity.Tx.Hash(childComplexity), true

	case "Tx.inputs":
		if e.complexity.Tx.Inputs == nil {
			break
		}

		return e.complexity.Tx.Inputs(childComplexity), true

	case "Tx.locktime":
		if e.complexity.Tx.LockTime == nil {
			break
		}

		return e.complexity.Tx.LockTime(childComplexity), true

	case "Tx.outputs":
		if e.complexity.Tx.Outputs == nil {
			break
		}

		return e.complexity.Tx.Outputs(childComplexity), true

	case "Tx.raw":
		if e.complexity.Tx.Raw == nil {
			break
		}

		return e.complexity.Tx.Raw(childComplexity), true

	case "Tx.seen":
		if e.complexity.Tx.Seen == nil {
			break
		}

		return e.complexity.Tx.Seen(childComplexity), true

	case "Tx.version":
		if e.complexity.Tx.Version == nil {
			break
		}

		return e.complexity.Tx.Version(childComplexity), true

	case "TxBlock.block":
		if e.complexity.TxBlock.Block == nil {
			break
		}

		return e.complexity.TxBlock.Block(childComplexity), true

	case "TxBlock.block_hash":
		if e.complexity.TxBlock.BlockHash == nil {
			break
		}

		return e.complexity.TxBlock.BlockHash(childComplexity), true

	case "TxBlock.index":
		if e.complexity.TxBlock.Index == nil {
			break
		}

		return e.complexity.TxBlock.Index(childComplexity), true

	case "TxBlock.tx":
		if e.complexity.TxBlock.Tx == nil {
			break
		}

		return e.complexity.TxBlock.Tx(childComplexity), true

	case "TxBlock.tx_hash":
		if e.complexity.TxBlock.TxHash == nil {
			break
		}

		return e.complexity.TxBlock.TxHash(childComplexity), true

	case "TxInput.hash":
		if e.complexity.TxInput.Hash == nil {
			break
		}

		return e.complexity.TxInput.Hash(childComplexity), true

	case "TxInput.index":
		if e.complexity.TxInput.Index == nil {
			break
		}

		return e.complexity.TxInput.Index(childComplexity), true

	case "TxInput.output":
		if e.complexity.TxInput.Output == nil {
			break
		}

		return e.complexity.TxInput.Output(childComplexity), true

	case "TxInput.prev_hash":
		if e.complexity.TxInput.PrevHash == nil {
			break
		}

		return e.complexity.TxInput.PrevHash(childComplexity), true

	case "TxInput.prev_index":
		if e.complexity.TxInput.PrevIndex == nil {
			break
		}

		return e.complexity.TxInput.PrevIndex(childComplexity), true

	case "TxInput.script":
		if e.complexity.TxInput.Script == nil {
			break
		}

		return e.complexity.TxInput.Script(childComplexity), true

	case "TxInput.sequence":
		if e.complexity.TxInput.Sequence == nil {
			break
		}

		return e.complexity.TxInput.Sequence(childComplexity), true

	case "TxInput.tx":
		if e.complexity.TxInput.Tx == nil {
			break
		}

		return e.complexity.TxInput.Tx(childComplexity), true

	case "TxOutput.amount":
		if e.complexity.TxOutput.Amount == nil {
			break
		}

		return e.complexity.TxOutput.Amount(childComplexity), true

	case "TxOutput.hash":
		if e.complexity.TxOutput.Hash == nil {
			break
		}

		return e.complexity.TxOutput.Hash(childComplexity), true

	case "TxOutput.index":
		if e.complexity.TxOutput.Index == nil {
			break
		}

		return e.complexity.TxOutput.Index(childComplexity), true

	case "TxOutput.lock":
		if e.complexity.TxOutput.Lock == nil {
			break
		}

		return e.complexity.TxOutput.Lock(childComplexity), true

	case "TxOutput.script":
		if e.complexity.TxOutput.Script == nil {
			break
		}

		return e.complexity.TxOutput.Script(childComplexity), true

	case "TxOutput.slp":
		if e.complexity.TxOutput.Slp == nil {
			break
		}

		return e.complexity.TxOutput.Slp(childComplexity), true

	case "TxOutput.slp_baton":
		if e.complexity.TxOutput.SlpBaton == nil {
			break
		}

		return e.complexity.TxOutput.SlpBaton(childComplexity), true

	case "TxOutput.spends":
		if e.complexity.TxOutput.Spends == nil {
			break
		}

		return e.complexity.TxOutput.Spends(childComplexity), true

	case "TxOutput.tx":
		if e.complexity.TxOutput.Tx == nil {
			break
		}

		return e.complexity.TxOutput.Tx(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap()
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Subscription:
		next := ec._Subscription(ctx, rc.Operation.SelectionSet)

		var buf bytes.Buffer
		return func(ctx context.Context) *graphql.Response {
			buf.Reset()
			data := next(ctx)

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/block.graphqls", Input: `type Block {
    hash: Hash!
    raw: Bytes!
    timestamp: Date!
    height: Int
    size: Int64
    tx_count: Int
    txs(start: Uint32): [TxBlock!]
}
`, BuiltIn: false},
	{Name: "../schema/lock.graphqls", Input: `type Lock {
    address: Address
    profile: Profile
    txs(start: Date, tx: Hash): [Tx!]
}
`, BuiltIn: false},
	{Name: "../schema/mutation.graphqls", Input: `type Mutation {
    broadcast(raw: String!): Boolean!
}
`, BuiltIn: false},
	{Name: "../schema/profile.graphqls", Input: `type Profile {
    lock: Lock!
    address: Address!
    name: SetName
    profile: SetProfile
    pic: SetPic
    following(start: Date): [Follow]
    followers(start: Date): [Follow]
    posts(start: Date, newest: Boolean): [Post]
    rooms(start: Date): [RoomFollow!]
}

type SetName {
    tx: Tx!
    tx_hash: Hash!
    lock: Lock!
    address: Address!
    name: String!
}

type SetProfile {
    tx: Tx!
    tx_hash: Hash!
    lock: Lock!
    address: Address!
    text: String!
}

type SetPic {
    tx: Tx!
    tx_hash: Hash!
    lock: Lock!
    address: Address!
    pic: String!
}

type Follow {
    tx: Tx!
    tx_hash: Hash!
    lock: Lock!
    address: Address!
    follow_lock: Lock!
    follow_address: Address!
    unfollow: Boolean!
}

# TODO: likes/replies need to be paginated
type Post {
    tx: Tx!
    tx_hash: Hash!
    lock: Lock!
    address: Address!
    text: String!
    likes: [Like!]
    parent: Post
    replies: [Post!]
    room: Room
}

type Like {
    tx: Tx!
    tx_hash: Hash!
    lock: Lock!
    address: Address!
    post_tx_hash: Hash!
    post: Post
    tip: Int64
}
`, BuiltIn: false},
	{Name: "../schema/query.graphqls", Input: `type Query {
    tx(hash: Hash!): Tx
    txs(hashes: [Hash!]): [Tx]
    address(address: Address!): Lock
    addresses(addresses: [Address!]): [Lock]
    block(hash: Hash!): Block
    block_newest: Block
    blocks(newest: Boolean, start: Uint32): [Block!]
    profiles(addresses: [Address!]): [Profile]
    posts(txHashes: [Hash!]): [Post]
    # posts_newest can take a date or a tx hash to start from for pagination
    posts_newest(start: Date, tx: Hash, limit: Uint32): [Post]
    room(name: String!): Room!
}

type Subscription {
    address(address: Address!): Tx
    addresses(addresses: [Address!]): Tx
    blocks: Block
    posts(hashes: [Hash!]): Post
    profiles(addresses: [Address!]): Profile
    rooms(names: [String!]): Post
    room_follows(addresses: [Address!]): RoomFollow
}
`, BuiltIn: false},
	{Name: "../schema/room.graphqls", Input: `type Room {
    name: String!
    posts(start: Int): [Post!]
    followers(start: Int): [RoomFollow!]
}

type RoomFollow {
    name: String!
    room: Room!
    lock: Lock!
    address: Address!
    unfollow: Boolean!
    tx_hash: Hash!
    tx: Tx!
}
`, BuiltIn: false},
	{Name: "../schema/scalar.graphqls", Input: `scalar Int32
scalar Int64
scalar Uint8
scalar Uint32
scalar Uint64
scalar HashIndex
scalar Date
scalar Hash
scalar Address
scalar Bytes
`, BuiltIn: false},
	{Name: "../schema/slp.graphqls", Input: `type SlpGenesis {
    tx: Tx!
    hash: Hash!
    token_type: Uint8!
    decimals: Uint8!
    output: SlpOutput!
    baton: SlpBaton!
    baton_index: Uint32!
    ticker: String!
    name: String!
    doc_url: String!
    doc_hash: String!
}

type SlpOutput {
    output: TxOutput!
    hash: Hash!
    index: Uint32!
    amount: Uint64!
    token_hash: Hash!
    genesis: SlpGenesis
}

type SlpBaton {
    output: TxOutput!
    hash: Hash!
    index: Uint32!
    token_hash: Hash!
    genesis: SlpGenesis
}

#type SlpMint {
#    tx: Tx!
#    hash: String!
#    output: SlpOutput!
#    baton: SlpBaton!
#    baton_index: Uint32!
#}
#
#type SlpSend {
#    tx: Tx!
#    hash: String!
#    outputs: [SlpOutput!]!
#}
`, BuiltIn: false},
	{Name: "../schema/tx.graphqls", Input: `type Tx {
    hash: Hash!
    raw: Bytes!
    inputs: [TxInput!]!
    outputs: [TxOutput!]!
    blocks: [TxBlock]
    seen: Date
    version:  Int32!
    locktime: Uint32!
}
`, BuiltIn: false},
	{Name: "../schema/tx_block.graphqls", Input: `type TxBlock {
    tx_hash: Hash!
    tx: Tx!
    block_hash: Hash!
    block: Block!
    index: Uint32!
}
`, BuiltIn: false},
	{Name: "../schema/tx_input.graphqls", Input: `type TxInput {
    tx: Tx!
    hash: Hash!
    index: Uint32!
    script: Bytes!
    prev_hash: Hash!
    prev_index: Uint32!
    output: TxOutput
    sequence: Uint32!
}
`, BuiltIn: false},
	{Name: "../schema/tx_output.graphqls", Input: `type TxOutput {
    tx: Tx!
    hash: Hash!
    index: Uint32!
    amount: Int64!
    script: Bytes!
    spends: [TxInput]
    slp: SlpOutput
    slp_baton: SlpBaton
    lock: Lock
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Block_txs_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *uint32
	if tmp, ok := rawArgs["start"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("start"))
		arg0, err = ec.unmarshalOUint322ᚖuint32(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["start"] = arg0
	return args, nil
}

func (ec *executionContext) field_Lock_txs_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.Date
	if tmp, ok := rawArgs["start"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("start"))
		arg0, err = ec.unmarshalODate2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐDate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["start"] = arg0
	var arg1 *model.Hash
	if tmp, ok := rawArgs["tx"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tx"))
		arg1, err = ec.unmarshalOHash2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐHash(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tx"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_broadcast_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["raw"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("raw"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["raw"] = arg0
	return args, nil
}

func (ec *executionContext) field_Profile_followers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.Date
	if tmp, ok := rawArgs["start"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("start"))
		arg0, err = ec.unmarshalODate2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐDate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["start"] = arg0
	return args, nil
}

func (ec *executionContext) field_Profile_following_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.Date
	if tmp, ok := rawArgs["start"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("start"))
		arg0, err = ec.unmarshalODate2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐDate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["start"] = arg0
	return args, nil
}

func (ec *executionContext) field_Profile_posts_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.Date
	if tmp, ok := rawArgs["start"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("start"))
		arg0, err = ec.unmarshalODate2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐDate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["start"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["newest"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("newest"))
		arg1, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["newest"] = arg1
	return args, nil
}

func (ec *executionContext) field_Profile_rooms_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.Date
	if tmp, ok := rawArgs["start"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("start"))
		arg0, err = ec.unmarshalODate2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐDate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["start"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_address_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.Address
	if tmp, ok := rawArgs["address"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("address"))
		arg0, err = ec.unmarshalNAddress2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐAddress(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["address"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_addresses_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []model.Address
	if tmp, ok := rawArgs["addresses"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addresses"))
		arg0, err = ec.unmarshalOAddress2ᚕgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐAddressᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["addresses"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_block_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.Hash
	if tmp, ok := rawArgs["hash"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hash"))
		arg0, err = ec.unmarshalNHash2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐHash(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hash"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_blocks_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *bool
	if tmp, ok := rawArgs["newest"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("newest"))
		arg0, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["newest"] = arg0
	var arg1 *uint32
	if tmp, ok := rawArgs["start"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("start"))
		arg1, err = ec.unmarshalOUint322ᚖuint32(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["start"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_posts_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []model.Hash
	if tmp, ok := rawArgs["txHashes"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("txHashes"))
		arg0, err = ec.unmarshalOHash2ᚕgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐHashᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["txHashes"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_posts_newest_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.Date
	if tmp, ok := rawArgs["start"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("start"))
		arg0, err = ec.unmarshalODate2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐDate(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["start"] = arg0
	var arg1 *model.Hash
	if tmp, ok := rawArgs["tx"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tx"))
		arg1, err = ec.unmarshalOHash2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐHash(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tx"] = arg1
	var arg2 *uint32
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg2, err = ec.unmarshalOUint322ᚖuint32(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_profiles_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []model.Address
	if tmp, ok := rawArgs["addresses"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addresses"))
		arg0, err = ec.unmarshalOAddress2ᚕgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐAddressᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["addresses"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_room_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_tx_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.Hash
	if tmp, ok := rawArgs["hash"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hash"))
		arg0, err = ec.unmarshalNHash2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐHash(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hash"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_txs_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []model.Hash
	if tmp, ok := rawArgs["hashes"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hashes"))
		arg0, err = ec.unmarshalOHash2ᚕgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐHashᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hashes"] = arg0
	return args, nil
}

func (ec *executionContext) field_Room_followers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["start"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("start"))
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["start"] = arg0
	return args, nil
}

func (ec *executionContext) field_Room_posts_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["start"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("start"))
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["start"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_address_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.Address
	if tmp, ok := rawArgs["address"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("address"))
		arg0, err = ec.unmarshalNAddress2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐAddress(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["address"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_addresses_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []model.Address
	if tmp, ok := rawArgs["addresses"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addresses"))
		arg0, err = ec.unmarshalOAddress2ᚕgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐAddressᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["addresses"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_posts_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []model.Hash
	if tmp, ok := rawArgs["hashes"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hashes"))
		arg0, err = ec.unmarshalOHash2ᚕgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐHashᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hashes"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_profiles_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []model.Address
	if tmp, ok := rawArgs["addresses"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addresses"))
		arg0, err = ec.unmarshalOAddress2ᚕgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐAddressᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["addresses"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_room_follows_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []model.Address
	if tmp, ok := rawArgs["addresses"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addresses"))
		arg0, err = ec.unmarshalOAddress2ᚕgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐAddressᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["addresses"] = arg0
	return args, nil
}

func (ec *executionContext) field_Subscription_rooms_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["names"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("names"))
		arg0, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["names"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Block_hash(ctx context.Context, field graphql.CollectedField, obj *model.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Hash)
	fc.Result = res
	return ec.marshalNHash2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐHash(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_hash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Hash does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Block_raw(ctx context.Context, field graphql.CollectedField, obj *model.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_raw(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Raw, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Bytes)
	fc.Result = res
	return ec.marshalNBytes2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐBytes(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_raw(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bytes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Block_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Date)
	fc.Result = res
	return ec.marshalNDate2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Block_height(ctx context.Context, field graphql.CollectedField, obj *model.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_height(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Height, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_height(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Block_size(ctx context.Context, field graphql.CollectedField, obj *model.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalOInt642int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_size(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Block_tx_count(ctx context.Context, field graphql.CollectedField, obj *model.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_tx_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TxCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_tx_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Block_txs(ctx context.Context, field graphql.CollectedField, obj *model.Block) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Block_txs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Txs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.TxBlock)
	fc.Result = res
	return ec.marshalOTxBlock2ᚕᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTxBlockᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Block_txs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Block",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tx_hash":
				return ec.fieldContext_TxBlock_tx_hash(ctx, field)
			case "tx":
				return ec.fieldContext_TxBlock_tx(ctx, field)
			case "block_hash":
				return ec.fieldContext_TxBlock_block_hash(ctx, field)
			case "block":
				return ec.fieldContext_TxBlock_block(ctx, field)
			case "index":
				return ec.fieldContext_TxBlock_index(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TxBlock", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Block_txs_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Follow_tx(ctx context.Context, field graphql.CollectedField, obj *model.Follow) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Follow_tx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Tx)
	fc.Result = res
	return ec.marshalNTx2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTx(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Follow_tx(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Follow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hash":
				return ec.fieldContext_Tx_hash(ctx, field)
			case "raw":
				return ec.fieldContext_Tx_raw(ctx, field)
			case "inputs":
				return ec.fieldContext_Tx_inputs(ctx, field)
			case "outputs":
				return ec.fieldContext_Tx_outputs(ctx, field)
			case "blocks":
				return ec.fieldContext_Tx_blocks(ctx, field)
			case "seen":
				return ec.fieldContext_Tx_seen(ctx, field)
			case "version":
				return ec.fieldContext_Tx_version(ctx, field)
			case "locktime":
				return ec.fieldContext_Tx_locktime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tx", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Follow_tx_hash(ctx context.Context, field graphql.CollectedField, obj *model.Follow) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Follow_tx_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TxHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Hash)
	fc.Result = res
	return ec.marshalNHash2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐHash(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Follow_tx_hash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Follow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Hash does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Follow_lock(ctx context.Context, field graphql.CollectedField, obj *model.Follow) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Follow_lock(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lock, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Lock)
	fc.Result = res
	return ec.marshalNLock2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐLock(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Follow_lock(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Follow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "address":
				return ec.fieldContext_Lock_address(ctx, field)
			case "profile":
				return ec.fieldContext_Lock_profile(ctx, field)
			case "txs":
				return ec.fieldContext_Lock_txs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Lock", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Follow_address(ctx context.Context, field graphql.CollectedField, obj *model.Follow) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Follow_address(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Address, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Address)
	fc.Result = res
	return ec.marshalNAddress2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Follow_address(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Follow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Follow_follow_lock(ctx context.Context, field graphql.CollectedField, obj *model.Follow) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Follow_follow_lock(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FollowLock, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Lock)
	fc.Result = res
	return ec.marshalNLock2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐLock(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Follow_follow_lock(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Follow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "address":
				return ec.fieldContext_Lock_address(ctx, field)
			case "profile":
				return ec.fieldContext_Lock_profile(ctx, field)
			case "txs":
				return ec.fieldContext_Lock_txs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Lock", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Follow_follow_address(ctx context.Context, field graphql.CollectedField, obj *model.Follow) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Follow_follow_address(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FollowAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Address)
	fc.Result = res
	return ec.marshalNAddress2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Follow_follow_address(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Follow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Follow_unfollow(ctx context.Context, field graphql.CollectedField, obj *model.Follow) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Follow_unfollow(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unfollow, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Follow_unfollow(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Follow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Like_tx(ctx context.Context, field graphql.CollectedField, obj *model.Like) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Like_tx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Tx)
	fc.Result = res
	return ec.marshalNTx2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTx(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Like_tx(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Like",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hash":
				return ec.fieldContext_Tx_hash(ctx, field)
			case "raw":
				return ec.fieldContext_Tx_raw(ctx, field)
			case "inputs":
				return ec.fieldContext_Tx_inputs(ctx, field)
			case "outputs":
				return ec.fieldContext_Tx_outputs(ctx, field)
			case "blocks":
				return ec.fieldContext_Tx_blocks(ctx, field)
			case "seen":
				return ec.fieldContext_Tx_seen(ctx, field)
			case "version":
				return ec.fieldContext_Tx_version(ctx, field)
			case "locktime":
				return ec.fieldContext_Tx_locktime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tx", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Like_tx_hash(ctx context.Context, field graphql.CollectedField, obj *model.Like) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Like_tx_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TxHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Hash)
	fc.Result = res
	return ec.marshalNHash2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐHash(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Like_tx_hash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Like",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Hash does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Like_lock(ctx context.Context, field graphql.CollectedField, obj *model.Like) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Like_lock(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lock, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Lock)
	fc.Result = res
	return ec.marshalNLock2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐLock(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Like_lock(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Like",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "address":
				return ec.fieldContext_Lock_address(ctx, field)
			case "profile":
				return ec.fieldContext_Lock_profile(ctx, field)
			case "txs":
				return ec.fieldContext_Lock_txs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Lock", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Like_address(ctx context.Context, field graphql.CollectedField, obj *model.Like) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Like_address(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Address, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Address)
	fc.Result = res
	return ec.marshalNAddress2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Like_address(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Like",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Like_post_tx_hash(ctx context.Context, field graphql.CollectedField, obj *model.Like) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Like_post_tx_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PostTxHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Hash)
	fc.Result = res
	return ec.marshalNHash2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐHash(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Like_post_tx_hash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Like",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Hash does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Like_post(ctx context.Context, field graphql.CollectedField, obj *model.Like) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Like_post(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Post, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Post)
	fc.Result = res
	return ec.marshalOPost2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐPost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Like_post(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Like",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tx":
				return ec.fieldContext_Post_tx(ctx, field)
			case "tx_hash":
				return ec.fieldContext_Post_tx_hash(ctx, field)
			case "lock":
				return ec.fieldContext_Post_lock(ctx, field)
			case "address":
				return ec.fieldContext_Post_address(ctx, field)
			case "text":
				return ec.fieldContext_Post_text(ctx, field)
			case "likes":
				return ec.fieldContext_Post_likes(ctx, field)
			case "parent":
				return ec.fieldContext_Post_parent(ctx, field)
			case "replies":
				return ec.fieldContext_Post_replies(ctx, field)
			case "room":
				return ec.fieldContext_Post_room(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Post", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Like_tip(ctx context.Context, field graphql.CollectedField, obj *model.Like) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Like_tip(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tip, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalOInt642int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Like_tip(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Like",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Lock_address(ctx context.Context, field graphql.CollectedField, obj *model.Lock) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Lock_address(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Address, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.Address)
	fc.Result = res
	return ec.marshalOAddress2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Lock_address(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Lock",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Lock_profile(ctx context.Context, field graphql.CollectedField, obj *model.Lock) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Lock_profile(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Profile, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Profile)
	fc.Result = res
	return ec.marshalOProfile2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐProfile(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Lock_profile(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Lock",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lock":
				return ec.fieldContext_Profile_lock(ctx, field)
			case "address":
				return ec.fieldContext_Profile_address(ctx, field)
			case "name":
				return ec.fieldContext_Profile_name(ctx, field)
			case "profile":
				return ec.fieldContext_Profile_profile(ctx, field)
			case "pic":
				return ec.fieldContext_Profile_pic(ctx, field)
			case "following":
				return ec.fieldContext_Profile_following(ctx, field)
			case "followers":
				return ec.fieldContext_Profile_followers(ctx, field)
			case "posts":
				return ec.fieldContext_Profile_posts(ctx, field)
			case "rooms":
				return ec.fieldContext_Profile_rooms(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Profile", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Lock_txs(ctx context.Context, field graphql.CollectedField, obj *model.Lock) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Lock_txs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Txs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Tx)
	fc.Result = res
	return ec.marshalOTx2ᚕᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTxᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Lock_txs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Lock",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hash":
				return ec.fieldContext_Tx_hash(ctx, field)
			case "raw":
				return ec.fieldContext_Tx_raw(ctx, field)
			case "inputs":
				return ec.fieldContext_Tx_inputs(ctx, field)
			case "outputs":
				return ec.fieldContext_Tx_outputs(ctx, field)
			case "blocks":
				return ec.fieldContext_Tx_blocks(ctx, field)
			case "seen":
				return ec.fieldContext_Tx_seen(ctx, field)
			case "version":
				return ec.fieldContext_Tx_version(ctx, field)
			case "locktime":
				return ec.fieldContext_Tx_locktime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tx", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Lock_txs_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_broadcast(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_broadcast(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Broadcast(rctx, fc.Args["raw"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_broadcast(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_broadcast_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Post_tx(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_tx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Tx)
	fc.Result = res
	return ec.marshalNTx2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTx(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_tx(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hash":
				return ec.fieldContext_Tx_hash(ctx, field)
			case "raw":
				return ec.fieldContext_Tx_raw(ctx, field)
			case "inputs":
				return ec.fieldContext_Tx_inputs(ctx, field)
			case "outputs":
				return ec.fieldContext_Tx_outputs(ctx, field)
			case "blocks":
				return ec.fieldContext_Tx_blocks(ctx, field)
			case "seen":
				return ec.fieldContext_Tx_seen(ctx, field)
			case "version":
				return ec.fieldContext_Tx_version(ctx, field)
			case "locktime":
				return ec.fieldContext_Tx_locktime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tx", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_tx_hash(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_tx_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TxHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Hash)
	fc.Result = res
	return ec.marshalNHash2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐHash(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_tx_hash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Hash does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_lock(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_lock(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lock, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Lock)
	fc.Result = res
	return ec.marshalNLock2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐLock(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_lock(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "address":
				return ec.fieldContext_Lock_address(ctx, field)
			case "profile":
				return ec.fieldContext_Lock_profile(ctx, field)
			case "txs":
				return ec.fieldContext_Lock_txs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Lock", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_address(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_address(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Address, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Address)
	fc.Result = res
	return ec.marshalNAddress2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_address(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_text(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_text(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Text, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_text(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_likes(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_likes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Likes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Like)
	fc.Result = res
	return ec.marshalOLike2ᚕᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐLikeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_likes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tx":
				return ec.fieldContext_Like_tx(ctx, field)
			case "tx_hash":
				return ec.fieldContext_Like_tx_hash(ctx, field)
			case "lock":
				return ec.fieldContext_Like_lock(ctx, field)
			case "address":
				return ec.fieldContext_Like_address(ctx, field)
			case "post_tx_hash":
				return ec.fieldContext_Like_post_tx_hash(ctx, field)
			case "post":
				return ec.fieldContext_Like_post(ctx, field)
			case "tip":
				return ec.fieldContext_Like_tip(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Like", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_parent(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_parent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Parent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Post)
	fc.Result = res
	return ec.marshalOPost2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐPost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_parent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tx":
				return ec.fieldContext_Post_tx(ctx, field)
			case "tx_hash":
				return ec.fieldContext_Post_tx_hash(ctx, field)
			case "lock":
				return ec.fieldContext_Post_lock(ctx, field)
			case "address":
				return ec.fieldContext_Post_address(ctx, field)
			case "text":
				return ec.fieldContext_Post_text(ctx, field)
			case "likes":
				return ec.fieldContext_Post_likes(ctx, field)
			case "parent":
				return ec.fieldContext_Post_parent(ctx, field)
			case "replies":
				return ec.fieldContext_Post_replies(ctx, field)
			case "room":
				return ec.fieldContext_Post_room(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Post", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_replies(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_replies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Replies, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Post)
	fc.Result = res
	return ec.marshalOPost2ᚕᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐPostᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_replies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tx":
				return ec.fieldContext_Post_tx(ctx, field)
			case "tx_hash":
				return ec.fieldContext_Post_tx_hash(ctx, field)
			case "lock":
				return ec.fieldContext_Post_lock(ctx, field)
			case "address":
				return ec.fieldContext_Post_address(ctx, field)
			case "text":
				return ec.fieldContext_Post_text(ctx, field)
			case "likes":
				return ec.fieldContext_Post_likes(ctx, field)
			case "parent":
				return ec.fieldContext_Post_parent(ctx, field)
			case "replies":
				return ec.fieldContext_Post_replies(ctx, field)
			case "room":
				return ec.fieldContext_Post_room(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Post", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Post_room(ctx context.Context, field graphql.CollectedField, obj *model.Post) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Post_room(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Room, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Room)
	fc.Result = res
	return ec.marshalORoom2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐRoom(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Post_room(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Post",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Room_name(ctx, field)
			case "posts":
				return ec.fieldContext_Room_posts(ctx, field)
			case "followers":
				return ec.fieldContext_Room_followers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Room", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_lock(ctx context.Context, field graphql.CollectedField, obj *model.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_lock(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lock, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Lock)
	fc.Result = res
	return ec.marshalNLock2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐLock(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_lock(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "address":
				return ec.fieldContext_Lock_address(ctx, field)
			case "profile":
				return ec.fieldContext_Lock_profile(ctx, field)
			case "txs":
				return ec.fieldContext_Lock_txs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Lock", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_address(ctx context.Context, field graphql.CollectedField, obj *model.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_address(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Address, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Address)
	fc.Result = res
	return ec.marshalNAddress2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_address(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_name(ctx context.Context, field graphql.CollectedField, obj *model.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.SetName)
	fc.Result = res
	return ec.marshalOSetName2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐSetName(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tx":
				return ec.fieldContext_SetName_tx(ctx, field)
			case "tx_hash":
				return ec.fieldContext_SetName_tx_hash(ctx, field)
			case "lock":
				return ec.fieldContext_SetName_lock(ctx, field)
			case "address":
				return ec.fieldContext_SetName_address(ctx, field)
			case "name":
				return ec.fieldContext_SetName_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SetName", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_profile(ctx context.Context, field graphql.CollectedField, obj *model.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_profile(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Profile, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.SetProfile)
	fc.Result = res
	return ec.marshalOSetProfile2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐSetProfile(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_profile(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tx":
				return ec.fieldContext_SetProfile_tx(ctx, field)
			case "tx_hash":
				return ec.fieldContext_SetProfile_tx_hash(ctx, field)
			case "lock":
				return ec.fieldContext_SetProfile_lock(ctx, field)
			case "address":
				return ec.fieldContext_SetProfile_address(ctx, field)
			case "text":
				return ec.fieldContext_SetProfile_text(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SetProfile", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_pic(ctx context.Context, field graphql.CollectedField, obj *model.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_pic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pic, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.SetPic)
	fc.Result = res
	return ec.marshalOSetPic2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐSetPic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_pic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tx":
				return ec.fieldContext_SetPic_tx(ctx, field)
			case "tx_hash":
				return ec.fieldContext_SetPic_tx_hash(ctx, field)
			case "lock":
				return ec.fieldContext_SetPic_lock(ctx, field)
			case "address":
				return ec.fieldContext_SetPic_address(ctx, field)
			case "pic":
				return ec.fieldContext_SetPic_pic(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SetPic", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Profile_following(ctx context.Context, field graphql.CollectedField, obj *model.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_following(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Following, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Follow)
	fc.Result = res
	return ec.marshalOFollow2ᚕᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐFollow(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_following(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tx":
				return ec.fieldContext_Follow_tx(ctx, field)
			case "tx_hash":
				return ec.fieldContext_Follow_tx_hash(ctx, field)
			case "lock":
				return ec.fieldContext_Follow_lock(ctx, field)
			case "address":
				return ec.fieldContext_Follow_address(ctx, field)
			case "follow_lock":
				return ec.fieldContext_Follow_follow_lock(ctx, field)
			case "follow_address":
				return ec.fieldContext_Follow_follow_address(ctx, field)
			case "unfollow":
				return ec.fieldContext_Follow_unfollow(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Follow", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Profile_following_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Profile_followers(ctx context.Context, field graphql.CollectedField, obj *model.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_followers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Followers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Follow)
	fc.Result = res
	return ec.marshalOFollow2ᚕᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐFollow(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_followers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tx":
				return ec.fieldContext_Follow_tx(ctx, field)
			case "tx_hash":
				return ec.fieldContext_Follow_tx_hash(ctx, field)
			case "lock":
				return ec.fieldContext_Follow_lock(ctx, field)
			case "address":
				return ec.fieldContext_Follow_address(ctx, field)
			case "follow_lock":
				return ec.fieldContext_Follow_follow_lock(ctx, field)
			case "follow_address":
				return ec.fieldContext_Follow_follow_address(ctx, field)
			case "unfollow":
				return ec.fieldContext_Follow_unfollow(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Follow", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Profile_followers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Profile_posts(ctx context.Context, field graphql.CollectedField, obj *model.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_posts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Posts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Post)
	fc.Result = res
	return ec.marshalOPost2ᚕᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐPost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_posts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tx":
				return ec.fieldContext_Post_tx(ctx, field)
			case "tx_hash":
				return ec.fieldContext_Post_tx_hash(ctx, field)
			case "lock":
				return ec.fieldContext_Post_lock(ctx, field)
			case "address":
				return ec.fieldContext_Post_address(ctx, field)
			case "text":
				return ec.fieldContext_Post_text(ctx, field)
			case "likes":
				return ec.fieldContext_Post_likes(ctx, field)
			case "parent":
				return ec.fieldContext_Post_parent(ctx, field)
			case "replies":
				return ec.fieldContext_Post_replies(ctx, field)
			case "room":
				return ec.fieldContext_Post_room(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Post", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Profile_posts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Profile_rooms(ctx context.Context, field graphql.CollectedField, obj *model.Profile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Profile_rooms(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rooms, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.RoomFollow)
	fc.Result = res
	return ec.marshalORoomFollow2ᚕᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐRoomFollowᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Profile_rooms(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Profile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_RoomFollow_name(ctx, field)
			case "room":
				return ec.fieldContext_RoomFollow_room(ctx, field)
			case "lock":
				return ec.fieldContext_RoomFollow_lock(ctx, field)
			case "address":
				return ec.fieldContext_RoomFollow_address(ctx, field)
			case "unfollow":
				return ec.fieldContext_RoomFollow_unfollow(ctx, field)
			case "tx_hash":
				return ec.fieldContext_RoomFollow_tx_hash(ctx, field)
			case "tx":
				return ec.fieldContext_RoomFollow_tx(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RoomFollow", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Profile_rooms_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_tx(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_tx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Tx(rctx, fc.Args["hash"].(model.Hash))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Tx)
	fc.Result = res
	return ec.marshalOTx2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTx(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_tx(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hash":
				return ec.fieldContext_Tx_hash(ctx, field)
			case "raw":
				return ec.fieldContext_Tx_raw(ctx, field)
			case "inputs":
				return ec.fieldContext_Tx_inputs(ctx, field)
			case "outputs":
				return ec.fieldContext_Tx_outputs(ctx, field)
			case "blocks":
				return ec.fieldContext_Tx_blocks(ctx, field)
			case "seen":
				return ec.fieldContext_Tx_seen(ctx, field)
			case "version":
				return ec.fieldContext_Tx_version(ctx, field)
			case "locktime":
				return ec.fieldContext_Tx_locktime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tx", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_tx_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_txs(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_txs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Txs(rctx, fc.Args["hashes"].([]model.Hash))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Tx)
	fc.Result = res
	return ec.marshalOTx2ᚕᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTx(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_txs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hash":
				return ec.fieldContext_Tx_hash(ctx, field)
			case "raw":
				return ec.fieldContext_Tx_raw(ctx, field)
			case "inputs":
				return ec.fieldContext_Tx_inputs(ctx, field)
			case "outputs":
				return ec.fieldContext_Tx_outputs(ctx, field)
			case "blocks":
				return ec.fieldContext_Tx_blocks(ctx, field)
			case "seen":
				return ec.fieldContext_Tx_seen(ctx, field)
			case "version":
				return ec.fieldContext_Tx_version(ctx, field)
			case "locktime":
				return ec.fieldContext_Tx_locktime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tx", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_txs_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_address(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_address(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Address(rctx, fc.Args["address"].(model.Address))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Lock)
	fc.Result = res
	return ec.marshalOLock2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐLock(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_address(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "address":
				return ec.fieldContext_Lock_address(ctx, field)
			case "profile":
				return ec.fieldContext_Lock_profile(ctx, field)
			case "txs":
				return ec.fieldContext_Lock_txs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Lock", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_address_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_addresses(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_addresses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Addresses(rctx, fc.Args["addresses"].([]model.Address))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Lock)
	fc.Result = res
	return ec.marshalOLock2ᚕᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐLock(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_addresses(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "address":
				return ec.fieldContext_Lock_address(ctx, field)
			case "profile":
				return ec.fieldContext_Lock_profile(ctx, field)
			case "txs":
				return ec.fieldContext_Lock_txs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Lock", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_addresses_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_block(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_block(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Block(rctx, fc.Args["hash"].(model.Hash))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Block)
	fc.Result = res
	return ec.marshalOBlock2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐBlock(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_block(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hash":
				return ec.fieldContext_Block_hash(ctx, field)
			case "raw":
				return ec.fieldContext_Block_raw(ctx, field)
			case "timestamp":
				return ec.fieldContext_Block_timestamp(ctx, field)
			case "height":
				return ec.fieldContext_Block_height(ctx, field)
			case "size":
				return ec.fieldContext_Block_size(ctx, field)
			case "tx_count":
				return ec.fieldContext_Block_tx_count(ctx, field)
			case "txs":
				return ec.fieldContext_Block_txs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Block", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_block_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_block_newest(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_block_newest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BlockNewest(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Block)
	fc.Result = res
	return ec.marshalOBlock2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐBlock(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_block_newest(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hash":
				return ec.fieldContext_Block_hash(ctx, field)
			case "raw":
				return ec.fieldContext_Block_raw(ctx, field)
			case "timestamp":
				return ec.fieldContext_Block_timestamp(ctx, field)
			case "height":
				return ec.fieldContext_Block_height(ctx, field)
			case "size":
				return ec.fieldContext_Block_size(ctx, field)
			case "tx_count":
				return ec.fieldContext_Block_tx_count(ctx, field)
			case "txs":
				return ec.fieldContext_Block_txs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Block", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_blocks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_blocks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Blocks(rctx, fc.Args["newest"].(*bool), fc.Args["start"].(*uint32))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Block)
	fc.Result = res
	return ec.marshalOBlock2ᚕᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐBlockᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_blocks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hash":
				return ec.fieldContext_Block_hash(ctx, field)
			case "raw":
				return ec.fieldContext_Block_raw(ctx, field)
			case "timestamp":
				return ec.fieldContext_Block_timestamp(ctx, field)
			case "height":
				return ec.fieldContext_Block_height(ctx, field)
			case "size":
				return ec.fieldContext_Block_size(ctx, field)
			case "tx_count":
				return ec.fieldContext_Block_tx_count(ctx, field)
			case "txs":
				return ec.fieldContext_Block_txs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Block", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_blocks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_profiles(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_profiles(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Profiles(rctx, fc.Args["addresses"].([]model.Address))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Profile)
	fc.Result = res
	return ec.marshalOProfile2ᚕᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐProfile(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_profiles(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lock":
				return ec.fieldContext_Profile_lock(ctx, field)
			case "address":
				return ec.fieldContext_Profile_address(ctx, field)
			case "name":
				return ec.fieldContext_Profile_name(ctx, field)
			case "profile":
				return ec.fieldContext_Profile_profile(ctx, field)
			case "pic":
				return ec.fieldContext_Profile_pic(ctx, field)
			case "following":
				return ec.fieldContext_Profile_following(ctx, field)
			case "followers":
				return ec.fieldContext_Profile_followers(ctx, field)
			case "posts":
				return ec.fieldContext_Profile_posts(ctx, field)
			case "rooms":
				return ec.fieldContext_Profile_rooms(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Profile", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_profiles_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_posts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_posts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Posts(rctx, fc.Args["txHashes"].([]model.Hash))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Post)
	fc.Result = res
	return ec.marshalOPost2ᚕᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐPost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_posts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tx":
				return ec.fieldContext_Post_tx(ctx, field)
			case "tx_hash":
				return ec.fieldContext_Post_tx_hash(ctx, field)
			case "lock":
				return ec.fieldContext_Post_lock(ctx, field)
			case "address":
				return ec.fieldContext_Post_address(ctx, field)
			case "text":
				return ec.fieldContext_Post_text(ctx, field)
			case "likes":
				return ec.fieldContext_Post_likes(ctx, field)
			case "parent":
				return ec.fieldContext_Post_parent(ctx, field)
			case "replies":
				return ec.fieldContext_Post_replies(ctx, field)
			case "room":
				return ec.fieldContext_Post_room(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Post", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_posts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_posts_newest(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_posts_newest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().PostsNewest(rctx, fc.Args["start"].(*model.Date), fc.Args["tx"].(*model.Hash), fc.Args["limit"].(*uint32))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Post)
	fc.Result = res
	return ec.marshalOPost2ᚕᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐPost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_posts_newest(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tx":
				return ec.fieldContext_Post_tx(ctx, field)
			case "tx_hash":
				return ec.fieldContext_Post_tx_hash(ctx, field)
			case "lock":
				return ec.fieldContext_Post_lock(ctx, field)
			case "address":
				return ec.fieldContext_Post_address(ctx, field)
			case "text":
				return ec.fieldContext_Post_text(ctx, field)
			case "likes":
				return ec.fieldContext_Post_likes(ctx, field)
			case "parent":
				return ec.fieldContext_Post_parent(ctx, field)
			case "replies":
				return ec.fieldContext_Post_replies(ctx, field)
			case "room":
				return ec.fieldContext_Post_room(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Post", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_posts_newest_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_room(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_room(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Room(rctx, fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Room)
	fc.Result = res
	return ec.marshalNRoom2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐRoom(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_room(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Room_name(ctx, field)
			case "posts":
				return ec.fieldContext_Room_posts(ctx, field)
			case "followers":
				return ec.fieldContext_Room_followers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Room", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_room_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Room_name(ctx context.Context, field graphql.CollectedField, obj *model.Room) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Room_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Room_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Room",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Room_posts(ctx context.Context, field graphql.CollectedField, obj *model.Room) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Room_posts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Posts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Post)
	fc.Result = res
	return ec.marshalOPost2ᚕᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐPostᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Room_posts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Room",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tx":
				return ec.fieldContext_Post_tx(ctx, field)
			case "tx_hash":
				return ec.fieldContext_Post_tx_hash(ctx, field)
			case "lock":
				return ec.fieldContext_Post_lock(ctx, field)
			case "address":
				return ec.fieldContext_Post_address(ctx, field)
			case "text":
				return ec.fieldContext_Post_text(ctx, field)
			case "likes":
				return ec.fieldContext_Post_likes(ctx, field)
			case "parent":
				return ec.fieldContext_Post_parent(ctx, field)
			case "replies":
				return ec.fieldContext_Post_replies(ctx, field)
			case "room":
				return ec.fieldContext_Post_room(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Post", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Room_posts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Room_followers(ctx context.Context, field graphql.CollectedField, obj *model.Room) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Room_followers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Followers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.RoomFollow)
	fc.Result = res
	return ec.marshalORoomFollow2ᚕᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐRoomFollowᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Room_followers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Room",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_RoomFollow_name(ctx, field)
			case "room":
				return ec.fieldContext_RoomFollow_room(ctx, field)
			case "lock":
				return ec.fieldContext_RoomFollow_lock(ctx, field)
			case "address":
				return ec.fieldContext_RoomFollow_address(ctx, field)
			case "unfollow":
				return ec.fieldContext_RoomFollow_unfollow(ctx, field)
			case "tx_hash":
				return ec.fieldContext_RoomFollow_tx_hash(ctx, field)
			case "tx":
				return ec.fieldContext_RoomFollow_tx(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RoomFollow", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Room_followers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _RoomFollow_name(ctx context.Context, field graphql.CollectedField, obj *model.RoomFollow) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoomFollow_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoomFollow_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoomFollow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoomFollow_room(ctx context.Context, field graphql.CollectedField, obj *model.RoomFollow) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoomFollow_room(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Room, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Room)
	fc.Result = res
	return ec.marshalNRoom2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐRoom(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoomFollow_room(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoomFollow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Room_name(ctx, field)
			case "posts":
				return ec.fieldContext_Room_posts(ctx, field)
			case "followers":
				return ec.fieldContext_Room_followers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Room", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoomFollow_lock(ctx context.Context, field graphql.CollectedField, obj *model.RoomFollow) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoomFollow_lock(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lock, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Lock)
	fc.Result = res
	return ec.marshalNLock2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐLock(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoomFollow_lock(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoomFollow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "address":
				return ec.fieldContext_Lock_address(ctx, field)
			case "profile":
				return ec.fieldContext_Lock_profile(ctx, field)
			case "txs":
				return ec.fieldContext_Lock_txs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Lock", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoomFollow_address(ctx context.Context, field graphql.CollectedField, obj *model.RoomFollow) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoomFollow_address(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Address, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Address)
	fc.Result = res
	return ec.marshalNAddress2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoomFollow_address(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoomFollow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoomFollow_unfollow(ctx context.Context, field graphql.CollectedField, obj *model.RoomFollow) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoomFollow_unfollow(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unfollow, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoomFollow_unfollow(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoomFollow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoomFollow_tx_hash(ctx context.Context, field graphql.CollectedField, obj *model.RoomFollow) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoomFollow_tx_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TxHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Hash)
	fc.Result = res
	return ec.marshalNHash2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐHash(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoomFollow_tx_hash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoomFollow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Hash does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoomFollow_tx(ctx context.Context, field graphql.CollectedField, obj *model.RoomFollow) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoomFollow_tx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Tx)
	fc.Result = res
	return ec.marshalNTx2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTx(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoomFollow_tx(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoomFollow",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hash":
				return ec.fieldContext_Tx_hash(ctx, field)
			case "raw":
				return ec.fieldContext_Tx_raw(ctx, field)
			case "inputs":
				return ec.fieldContext_Tx_inputs(ctx, field)
			case "outputs":
				return ec.fieldContext_Tx_outputs(ctx, field)
			case "blocks":
				return ec.fieldContext_Tx_blocks(ctx, field)
			case "seen":
				return ec.fieldContext_Tx_seen(ctx, field)
			case "version":
				return ec.fieldContext_Tx_version(ctx, field)
			case "locktime":
				return ec.fieldContext_Tx_locktime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tx", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SetName_tx(ctx context.Context, field graphql.CollectedField, obj *model.SetName) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SetName_tx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Tx)
	fc.Result = res
	return ec.marshalNTx2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTx(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SetName_tx(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SetName",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hash":
				return ec.fieldContext_Tx_hash(ctx, field)
			case "raw":
				return ec.fieldContext_Tx_raw(ctx, field)
			case "inputs":
				return ec.fieldContext_Tx_inputs(ctx, field)
			case "outputs":
				return ec.fieldContext_Tx_outputs(ctx, field)
			case "blocks":
				return ec.fieldContext_Tx_blocks(ctx, field)
			case "seen":
				return ec.fieldContext_Tx_seen(ctx, field)
			case "version":
				return ec.fieldContext_Tx_version(ctx, field)
			case "locktime":
				return ec.fieldContext_Tx_locktime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tx", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SetName_tx_hash(ctx context.Context, field graphql.CollectedField, obj *model.SetName) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SetName_tx_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TxHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Hash)
	fc.Result = res
	return ec.marshalNHash2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐHash(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SetName_tx_hash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SetName",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Hash does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SetName_lock(ctx context.Context, field graphql.CollectedField, obj *model.SetName) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SetName_lock(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lock, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Lock)
	fc.Result = res
	return ec.marshalNLock2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐLock(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SetName_lock(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SetName",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "address":
				return ec.fieldContext_Lock_address(ctx, field)
			case "profile":
				return ec.fieldContext_Lock_profile(ctx, field)
			case "txs":
				return ec.fieldContext_Lock_txs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Lock", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SetName_address(ctx context.Context, field graphql.CollectedField, obj *model.SetName) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SetName_address(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Address, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Address)
	fc.Result = res
	return ec.marshalNAddress2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SetName_address(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SetName",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SetName_name(ctx context.Context, field graphql.CollectedField, obj *model.SetName) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SetName_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SetName_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SetName",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SetPic_tx(ctx context.Context, field graphql.CollectedField, obj *model.SetPic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SetPic_tx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Tx)
	fc.Result = res
	return ec.marshalNTx2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTx(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SetPic_tx(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SetPic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hash":
				return ec.fieldContext_Tx_hash(ctx, field)
			case "raw":
				return ec.fieldContext_Tx_raw(ctx, field)
			case "inputs":
				return ec.fieldContext_Tx_inputs(ctx, field)
			case "outputs":
				return ec.fieldContext_Tx_outputs(ctx, field)
			case "blocks":
				return ec.fieldContext_Tx_blocks(ctx, field)
			case "seen":
				return ec.fieldContext_Tx_seen(ctx, field)
			case "version":
				return ec.fieldContext_Tx_version(ctx, field)
			case "locktime":
				return ec.fieldContext_Tx_locktime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tx", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SetPic_tx_hash(ctx context.Context, field graphql.CollectedField, obj *model.SetPic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SetPic_tx_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TxHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Hash)
	fc.Result = res
	return ec.marshalNHash2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐHash(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SetPic_tx_hash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SetPic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Hash does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SetPic_lock(ctx context.Context, field graphql.CollectedField, obj *model.SetPic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SetPic_lock(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lock, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Lock)
	fc.Result = res
	return ec.marshalNLock2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐLock(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SetPic_lock(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SetPic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "address":
				return ec.fieldContext_Lock_address(ctx, field)
			case "profile":
				return ec.fieldContext_Lock_profile(ctx, field)
			case "txs":
				return ec.fieldContext_Lock_txs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Lock", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SetPic_address(ctx context.Context, field graphql.CollectedField, obj *model.SetPic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SetPic_address(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Address, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Address)
	fc.Result = res
	return ec.marshalNAddress2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SetPic_address(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SetPic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SetPic_pic(ctx context.Context, field graphql.CollectedField, obj *model.SetPic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SetPic_pic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pic, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SetPic_pic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SetPic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SetProfile_tx(ctx context.Context, field graphql.CollectedField, obj *model.SetProfile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SetProfile_tx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Tx)
	fc.Result = res
	return ec.marshalNTx2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTx(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SetProfile_tx(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SetProfile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hash":
				return ec.fieldContext_Tx_hash(ctx, field)
			case "raw":
				return ec.fieldContext_Tx_raw(ctx, field)
			case "inputs":
				return ec.fieldContext_Tx_inputs(ctx, field)
			case "outputs":
				return ec.fieldContext_Tx_outputs(ctx, field)
			case "blocks":
				return ec.fieldContext_Tx_blocks(ctx, field)
			case "seen":
				return ec.fieldContext_Tx_seen(ctx, field)
			case "version":
				return ec.fieldContext_Tx_version(ctx, field)
			case "locktime":
				return ec.fieldContext_Tx_locktime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tx", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SetProfile_tx_hash(ctx context.Context, field graphql.CollectedField, obj *model.SetProfile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SetProfile_tx_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TxHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Hash)
	fc.Result = res
	return ec.marshalNHash2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐHash(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SetProfile_tx_hash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SetProfile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Hash does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SetProfile_lock(ctx context.Context, field graphql.CollectedField, obj *model.SetProfile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SetProfile_lock(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lock, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Lock)
	fc.Result = res
	return ec.marshalNLock2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐLock(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SetProfile_lock(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SetProfile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "address":
				return ec.fieldContext_Lock_address(ctx, field)
			case "profile":
				return ec.fieldContext_Lock_profile(ctx, field)
			case "txs":
				return ec.fieldContext_Lock_txs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Lock", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SetProfile_address(ctx context.Context, field graphql.CollectedField, obj *model.SetProfile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SetProfile_address(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Address, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Address)
	fc.Result = res
	return ec.marshalNAddress2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐAddress(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SetProfile_address(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SetProfile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SetProfile_text(ctx context.Context, field graphql.CollectedField, obj *model.SetProfile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SetProfile_text(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Text, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SetProfile_text(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SetProfile",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlpBaton_output(ctx context.Context, field graphql.CollectedField, obj *model.SlpBaton) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SlpBaton_output(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Output, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.TxOutput)
	fc.Result = res
	return ec.marshalNTxOutput2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTxOutput(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SlpBaton_output(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlpBaton",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tx":
				return ec.fieldContext_TxOutput_tx(ctx, field)
			case "hash":
				return ec.fieldContext_TxOutput_hash(ctx, field)
			case "index":
				return ec.fieldContext_TxOutput_index(ctx, field)
			case "amount":
				return ec.fieldContext_TxOutput_amount(ctx, field)
			case "script":
				return ec.fieldContext_TxOutput_script(ctx, field)
			case "spends":
				return ec.fieldContext_TxOutput_spends(ctx, field)
			case "slp":
				return ec.fieldContext_TxOutput_slp(ctx, field)
			case "slp_baton":
				return ec.fieldContext_TxOutput_slp_baton(ctx, field)
			case "lock":
				return ec.fieldContext_TxOutput_lock(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TxOutput", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlpBaton_hash(ctx context.Context, field graphql.CollectedField, obj *model.SlpBaton) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SlpBaton_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Hash)
	fc.Result = res
	return ec.marshalNHash2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐHash(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SlpBaton_hash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlpBaton",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Hash does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlpBaton_index(ctx context.Context, field graphql.CollectedField, obj *model.SlpBaton) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SlpBaton_index(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Index, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint32)
	fc.Result = res
	return ec.marshalNUint322uint32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SlpBaton_index(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlpBaton",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint32 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlpBaton_token_hash(ctx context.Context, field graphql.CollectedField, obj *model.SlpBaton) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SlpBaton_token_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TokenHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Hash)
	fc.Result = res
	return ec.marshalNHash2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐHash(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SlpBaton_token_hash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlpBaton",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Hash does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlpBaton_genesis(ctx context.Context, field graphql.CollectedField, obj *model.SlpBaton) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SlpBaton_genesis(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Genesis, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.SlpGenesis)
	fc.Result = res
	return ec.marshalOSlpGenesis2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐSlpGenesis(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SlpBaton_genesis(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlpBaton",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tx":
				return ec.fieldContext_SlpGenesis_tx(ctx, field)
			case "hash":
				return ec.fieldContext_SlpGenesis_hash(ctx, field)
			case "token_type":
				return ec.fieldContext_SlpGenesis_token_type(ctx, field)
			case "decimals":
				return ec.fieldContext_SlpGenesis_decimals(ctx, field)
			case "output":
				return ec.fieldContext_SlpGenesis_output(ctx, field)
			case "baton":
				return ec.fieldContext_SlpGenesis_baton(ctx, field)
			case "baton_index":
				return ec.fieldContext_SlpGenesis_baton_index(ctx, field)
			case "ticker":
				return ec.fieldContext_SlpGenesis_ticker(ctx, field)
			case "name":
				return ec.fieldContext_SlpGenesis_name(ctx, field)
			case "doc_url":
				return ec.fieldContext_SlpGenesis_doc_url(ctx, field)
			case "doc_hash":
				return ec.fieldContext_SlpGenesis_doc_hash(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SlpGenesis", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlpGenesis_tx(ctx context.Context, field graphql.CollectedField, obj *model.SlpGenesis) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SlpGenesis_tx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Tx)
	fc.Result = res
	return ec.marshalNTx2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTx(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SlpGenesis_tx(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlpGenesis",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hash":
				return ec.fieldContext_Tx_hash(ctx, field)
			case "raw":
				return ec.fieldContext_Tx_raw(ctx, field)
			case "inputs":
				return ec.fieldContext_Tx_inputs(ctx, field)
			case "outputs":
				return ec.fieldContext_Tx_outputs(ctx, field)
			case "blocks":
				return ec.fieldContext_Tx_blocks(ctx, field)
			case "seen":
				return ec.fieldContext_Tx_seen(ctx, field)
			case "version":
				return ec.fieldContext_Tx_version(ctx, field)
			case "locktime":
				return ec.fieldContext_Tx_locktime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tx", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlpGenesis_hash(ctx context.Context, field graphql.CollectedField, obj *model.SlpGenesis) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SlpGenesis_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Hash)
	fc.Result = res
	return ec.marshalNHash2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐHash(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SlpGenesis_hash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlpGenesis",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Hash does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlpGenesis_token_type(ctx context.Context, field graphql.CollectedField, obj *model.SlpGenesis) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SlpGenesis_token_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TokenType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Uint8)
	fc.Result = res
	return ec.marshalNUint82githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐUint8(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SlpGenesis_token_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlpGenesis",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint8 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlpGenesis_decimals(ctx context.Context, field graphql.CollectedField, obj *model.SlpGenesis) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SlpGenesis_decimals(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Decimals, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Uint8)
	fc.Result = res
	return ec.marshalNUint82githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐUint8(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SlpGenesis_decimals(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlpGenesis",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint8 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlpGenesis_output(ctx context.Context, field graphql.CollectedField, obj *model.SlpGenesis) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SlpGenesis_output(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Output, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.SlpOutput)
	fc.Result = res
	return ec.marshalNSlpOutput2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐSlpOutput(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SlpGenesis_output(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlpGenesis",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "output":
				return ec.fieldContext_SlpOutput_output(ctx, field)
			case "hash":
				return ec.fieldContext_SlpOutput_hash(ctx, field)
			case "index":
				return ec.fieldContext_SlpOutput_index(ctx, field)
			case "amount":
				return ec.fieldContext_SlpOutput_amount(ctx, field)
			case "token_hash":
				return ec.fieldContext_SlpOutput_token_hash(ctx, field)
			case "genesis":
				return ec.fieldContext_SlpOutput_genesis(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SlpOutput", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlpGenesis_baton(ctx context.Context, field graphql.CollectedField, obj *model.SlpGenesis) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SlpGenesis_baton(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Baton, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.SlpBaton)
	fc.Result = res
	return ec.marshalNSlpBaton2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐSlpBaton(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SlpGenesis_baton(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlpGenesis",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "output":
				return ec.fieldContext_SlpBaton_output(ctx, field)
			case "hash":
				return ec.fieldContext_SlpBaton_hash(ctx, field)
			case "index":
				return ec.fieldContext_SlpBaton_index(ctx, field)
			case "token_hash":
				return ec.fieldContext_SlpBaton_token_hash(ctx, field)
			case "genesis":
				return ec.fieldContext_SlpBaton_genesis(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SlpBaton", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlpGenesis_baton_index(ctx context.Context, field graphql.CollectedField, obj *model.SlpGenesis) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SlpGenesis_baton_index(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BatonIndex, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint32)
	fc.Result = res
	return ec.marshalNUint322uint32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SlpGenesis_baton_index(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlpGenesis",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint32 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlpGenesis_ticker(ctx context.Context, field graphql.CollectedField, obj *model.SlpGenesis) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SlpGenesis_ticker(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ticker, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SlpGenesis_ticker(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlpGenesis",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlpGenesis_name(ctx context.Context, field graphql.CollectedField, obj *model.SlpGenesis) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SlpGenesis_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SlpGenesis_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlpGenesis",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlpGenesis_doc_url(ctx context.Context, field graphql.CollectedField, obj *model.SlpGenesis) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SlpGenesis_doc_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DocURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SlpGenesis_doc_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlpGenesis",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlpGenesis_doc_hash(ctx context.Context, field graphql.CollectedField, obj *model.SlpGenesis) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SlpGenesis_doc_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DocHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SlpGenesis_doc_hash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlpGenesis",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlpOutput_output(ctx context.Context, field graphql.CollectedField, obj *model.SlpOutput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SlpOutput_output(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Output, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.TxOutput)
	fc.Result = res
	return ec.marshalNTxOutput2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTxOutput(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SlpOutput_output(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlpOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tx":
				return ec.fieldContext_TxOutput_tx(ctx, field)
			case "hash":
				return ec.fieldContext_TxOutput_hash(ctx, field)
			case "index":
				return ec.fieldContext_TxOutput_index(ctx, field)
			case "amount":
				return ec.fieldContext_TxOutput_amount(ctx, field)
			case "script":
				return ec.fieldContext_TxOutput_script(ctx, field)
			case "spends":
				return ec.fieldContext_TxOutput_spends(ctx, field)
			case "slp":
				return ec.fieldContext_TxOutput_slp(ctx, field)
			case "slp_baton":
				return ec.fieldContext_TxOutput_slp_baton(ctx, field)
			case "lock":
				return ec.fieldContext_TxOutput_lock(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TxOutput", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlpOutput_hash(ctx context.Context, field graphql.CollectedField, obj *model.SlpOutput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SlpOutput_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Hash)
	fc.Result = res
	return ec.marshalNHash2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐHash(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SlpOutput_hash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlpOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Hash does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlpOutput_index(ctx context.Context, field graphql.CollectedField, obj *model.SlpOutput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SlpOutput_index(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Index, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint32)
	fc.Result = res
	return ec.marshalNUint322uint32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SlpOutput_index(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlpOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint32 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlpOutput_amount(ctx context.Context, field graphql.CollectedField, obj *model.SlpOutput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SlpOutput_amount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Amount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNUint642uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SlpOutput_amount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlpOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlpOutput_token_hash(ctx context.Context, field graphql.CollectedField, obj *model.SlpOutput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SlpOutput_token_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TokenHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Hash)
	fc.Result = res
	return ec.marshalNHash2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐHash(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SlpOutput_token_hash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlpOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Hash does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlpOutput_genesis(ctx context.Context, field graphql.CollectedField, obj *model.SlpOutput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SlpOutput_genesis(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Genesis, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.SlpGenesis)
	fc.Result = res
	return ec.marshalOSlpGenesis2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐSlpGenesis(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SlpOutput_genesis(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlpOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tx":
				return ec.fieldContext_SlpGenesis_tx(ctx, field)
			case "hash":
				return ec.fieldContext_SlpGenesis_hash(ctx, field)
			case "token_type":
				return ec.fieldContext_SlpGenesis_token_type(ctx, field)
			case "decimals":
				return ec.fieldContext_SlpGenesis_decimals(ctx, field)
			case "output":
				return ec.fieldContext_SlpGenesis_output(ctx, field)
			case "baton":
				return ec.fieldContext_SlpGenesis_baton(ctx, field)
			case "baton_index":
				return ec.fieldContext_SlpGenesis_baton_index(ctx, field)
			case "ticker":
				return ec.fieldContext_SlpGenesis_ticker(ctx, field)
			case "name":
				return ec.fieldContext_SlpGenesis_name(ctx, field)
			case "doc_url":
				return ec.fieldContext_SlpGenesis_doc_url(ctx, field)
			case "doc_hash":
				return ec.fieldContext_SlpGenesis_doc_hash(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SlpGenesis", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_address(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_address(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().Address(rctx, fc.Args["address"].(model.Address))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.Tx):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalOTx2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTx(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_address(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hash":
				return ec.fieldContext_Tx_hash(ctx, field)
			case "raw":
				return ec.fieldContext_Tx_raw(ctx, field)
			case "inputs":
				return ec.fieldContext_Tx_inputs(ctx, field)
			case "outputs":
				return ec.fieldContext_Tx_outputs(ctx, field)
			case "blocks":
				return ec.fieldContext_Tx_blocks(ctx, field)
			case "seen":
				return ec.fieldContext_Tx_seen(ctx, field)
			case "version":
				return ec.fieldContext_Tx_version(ctx, field)
			case "locktime":
				return ec.fieldContext_Tx_locktime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tx", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_address_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_addresses(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_addresses(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().Addresses(rctx, fc.Args["addresses"].([]model.Address))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.Tx):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalOTx2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTx(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_addresses(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hash":
				return ec.fieldContext_Tx_hash(ctx, field)
			case "raw":
				return ec.fieldContext_Tx_raw(ctx, field)
			case "inputs":
				return ec.fieldContext_Tx_inputs(ctx, field)
			case "outputs":
				return ec.fieldContext_Tx_outputs(ctx, field)
			case "blocks":
				return ec.fieldContext_Tx_blocks(ctx, field)
			case "seen":
				return ec.fieldContext_Tx_seen(ctx, field)
			case "version":
				return ec.fieldContext_Tx_version(ctx, field)
			case "locktime":
				return ec.fieldContext_Tx_locktime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tx", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_addresses_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_blocks(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_blocks(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().Blocks(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.Block):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalOBlock2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐBlock(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_blocks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hash":
				return ec.fieldContext_Block_hash(ctx, field)
			case "raw":
				return ec.fieldContext_Block_raw(ctx, field)
			case "timestamp":
				return ec.fieldContext_Block_timestamp(ctx, field)
			case "height":
				return ec.fieldContext_Block_height(ctx, field)
			case "size":
				return ec.fieldContext_Block_size(ctx, field)
			case "tx_count":
				return ec.fieldContext_Block_tx_count(ctx, field)
			case "txs":
				return ec.fieldContext_Block_txs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Block", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_posts(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_posts(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().Posts(rctx, fc.Args["hashes"].([]model.Hash))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.Post):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalOPost2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐPost(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_posts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tx":
				return ec.fieldContext_Post_tx(ctx, field)
			case "tx_hash":
				return ec.fieldContext_Post_tx_hash(ctx, field)
			case "lock":
				return ec.fieldContext_Post_lock(ctx, field)
			case "address":
				return ec.fieldContext_Post_address(ctx, field)
			case "text":
				return ec.fieldContext_Post_text(ctx, field)
			case "likes":
				return ec.fieldContext_Post_likes(ctx, field)
			case "parent":
				return ec.fieldContext_Post_parent(ctx, field)
			case "replies":
				return ec.fieldContext_Post_replies(ctx, field)
			case "room":
				return ec.fieldContext_Post_room(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Post", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_posts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_profiles(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_profiles(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().Profiles(rctx, fc.Args["addresses"].([]model.Address))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.Profile):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalOProfile2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐProfile(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_profiles(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lock":
				return ec.fieldContext_Profile_lock(ctx, field)
			case "address":
				return ec.fieldContext_Profile_address(ctx, field)
			case "name":
				return ec.fieldContext_Profile_name(ctx, field)
			case "profile":
				return ec.fieldContext_Profile_profile(ctx, field)
			case "pic":
				return ec.fieldContext_Profile_pic(ctx, field)
			case "following":
				return ec.fieldContext_Profile_following(ctx, field)
			case "followers":
				return ec.fieldContext_Profile_followers(ctx, field)
			case "posts":
				return ec.fieldContext_Profile_posts(ctx, field)
			case "rooms":
				return ec.fieldContext_Profile_rooms(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Profile", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_profiles_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_rooms(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_rooms(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().Rooms(rctx, fc.Args["names"].([]string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.Post):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalOPost2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐPost(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_rooms(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tx":
				return ec.fieldContext_Post_tx(ctx, field)
			case "tx_hash":
				return ec.fieldContext_Post_tx_hash(ctx, field)
			case "lock":
				return ec.fieldContext_Post_lock(ctx, field)
			case "address":
				return ec.fieldContext_Post_address(ctx, field)
			case "text":
				return ec.fieldContext_Post_text(ctx, field)
			case "likes":
				return ec.fieldContext_Post_likes(ctx, field)
			case "parent":
				return ec.fieldContext_Post_parent(ctx, field)
			case "replies":
				return ec.fieldContext_Post_replies(ctx, field)
			case "room":
				return ec.fieldContext_Post_room(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Post", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_rooms_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_room_follows(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_room_follows(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().RoomFollows(rctx, fc.Args["addresses"].([]model.Address))
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		select {
		case res, ok := <-resTmp.(<-chan *model.RoomFollow):
			if !ok {
				return nil
			}
			return graphql.WriterFunc(func(w io.Writer) {
				w.Write([]byte{'{'})
				graphql.MarshalString(field.Alias).MarshalGQL(w)
				w.Write([]byte{':'})
				ec.marshalORoomFollow2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐRoomFollow(ctx, field.Selections, res).MarshalGQL(w)
				w.Write([]byte{'}'})
			})
		case <-ctx.Done():
			return nil
		}
	}
}

func (ec *executionContext) fieldContext_Subscription_room_follows(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_RoomFollow_name(ctx, field)
			case "room":
				return ec.fieldContext_RoomFollow_room(ctx, field)
			case "lock":
				return ec.fieldContext_RoomFollow_lock(ctx, field)
			case "address":
				return ec.fieldContext_RoomFollow_address(ctx, field)
			case "unfollow":
				return ec.fieldContext_RoomFollow_unfollow(ctx, field)
			case "tx_hash":
				return ec.fieldContext_RoomFollow_tx_hash(ctx, field)
			case "tx":
				return ec.fieldContext_RoomFollow_tx(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RoomFollow", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Subscription_room_follows_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Tx_hash(ctx context.Context, field graphql.CollectedField, obj *model.Tx) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tx_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Hash)
	fc.Result = res
	return ec.marshalNHash2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐHash(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tx_hash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tx",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Hash does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tx_raw(ctx context.Context, field graphql.CollectedField, obj *model.Tx) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tx_raw(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Raw, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Bytes)
	fc.Result = res
	return ec.marshalNBytes2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐBytes(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tx_raw(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tx",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bytes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tx_inputs(ctx context.Context, field graphql.CollectedField, obj *model.Tx) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tx_inputs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Inputs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.TxInput)
	fc.Result = res
	return ec.marshalNTxInput2ᚕᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTxInputᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tx_inputs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tx",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tx":
				return ec.fieldContext_TxInput_tx(ctx, field)
			case "hash":
				return ec.fieldContext_TxInput_hash(ctx, field)
			case "index":
				return ec.fieldContext_TxInput_index(ctx, field)
			case "script":
				return ec.fieldContext_TxInput_script(ctx, field)
			case "prev_hash":
				return ec.fieldContext_TxInput_prev_hash(ctx, field)
			case "prev_index":
				return ec.fieldContext_TxInput_prev_index(ctx, field)
			case "output":
				return ec.fieldContext_TxInput_output(ctx, field)
			case "sequence":
				return ec.fieldContext_TxInput_sequence(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TxInput", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tx_outputs(ctx context.Context, field graphql.CollectedField, obj *model.Tx) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tx_outputs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Outputs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.TxOutput)
	fc.Result = res
	return ec.marshalNTxOutput2ᚕᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTxOutputᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tx_outputs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tx",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tx":
				return ec.fieldContext_TxOutput_tx(ctx, field)
			case "hash":
				return ec.fieldContext_TxOutput_hash(ctx, field)
			case "index":
				return ec.fieldContext_TxOutput_index(ctx, field)
			case "amount":
				return ec.fieldContext_TxOutput_amount(ctx, field)
			case "script":
				return ec.fieldContext_TxOutput_script(ctx, field)
			case "spends":
				return ec.fieldContext_TxOutput_spends(ctx, field)
			case "slp":
				return ec.fieldContext_TxOutput_slp(ctx, field)
			case "slp_baton":
				return ec.fieldContext_TxOutput_slp_baton(ctx, field)
			case "lock":
				return ec.fieldContext_TxOutput_lock(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TxOutput", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tx_blocks(ctx context.Context, field graphql.CollectedField, obj *model.Tx) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tx_blocks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Blocks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.TxBlock)
	fc.Result = res
	return ec.marshalOTxBlock2ᚕᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTxBlock(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tx_blocks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tx",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tx_hash":
				return ec.fieldContext_TxBlock_tx_hash(ctx, field)
			case "tx":
				return ec.fieldContext_TxBlock_tx(ctx, field)
			case "block_hash":
				return ec.fieldContext_TxBlock_block_hash(ctx, field)
			case "block":
				return ec.fieldContext_TxBlock_block(ctx, field)
			case "index":
				return ec.fieldContext_TxBlock_index(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TxBlock", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tx_seen(ctx context.Context, field graphql.CollectedField, obj *model.Tx) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tx_seen(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Seen, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.Date)
	fc.Result = res
	return ec.marshalODate2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tx_seen(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tx",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tx_version(ctx context.Context, field graphql.CollectedField, obj *model.Tx) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tx_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalNInt322int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tx_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tx",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int32 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tx_locktime(ctx context.Context, field graphql.CollectedField, obj *model.Tx) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tx_locktime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LockTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint32)
	fc.Result = res
	return ec.marshalNUint322uint32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tx_locktime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tx",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint32 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TxBlock_tx_hash(ctx context.Context, field graphql.CollectedField, obj *model.TxBlock) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TxBlock_tx_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TxHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Hash)
	fc.Result = res
	return ec.marshalNHash2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐHash(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TxBlock_tx_hash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TxBlock",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Hash does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TxBlock_tx(ctx context.Context, field graphql.CollectedField, obj *model.TxBlock) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TxBlock_tx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Tx)
	fc.Result = res
	return ec.marshalNTx2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTx(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TxBlock_tx(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TxBlock",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hash":
				return ec.fieldContext_Tx_hash(ctx, field)
			case "raw":
				return ec.fieldContext_Tx_raw(ctx, field)
			case "inputs":
				return ec.fieldContext_Tx_inputs(ctx, field)
			case "outputs":
				return ec.fieldContext_Tx_outputs(ctx, field)
			case "blocks":
				return ec.fieldContext_Tx_blocks(ctx, field)
			case "seen":
				return ec.fieldContext_Tx_seen(ctx, field)
			case "version":
				return ec.fieldContext_Tx_version(ctx, field)
			case "locktime":
				return ec.fieldContext_Tx_locktime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tx", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TxBlock_block_hash(ctx context.Context, field graphql.CollectedField, obj *model.TxBlock) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TxBlock_block_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Hash)
	fc.Result = res
	return ec.marshalNHash2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐHash(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TxBlock_block_hash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TxBlock",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Hash does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TxBlock_block(ctx context.Context, field graphql.CollectedField, obj *model.TxBlock) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TxBlock_block(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Block, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Block)
	fc.Result = res
	return ec.marshalNBlock2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐBlock(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TxBlock_block(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TxBlock",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hash":
				return ec.fieldContext_Block_hash(ctx, field)
			case "raw":
				return ec.fieldContext_Block_raw(ctx, field)
			case "timestamp":
				return ec.fieldContext_Block_timestamp(ctx, field)
			case "height":
				return ec.fieldContext_Block_height(ctx, field)
			case "size":
				return ec.fieldContext_Block_size(ctx, field)
			case "tx_count":
				return ec.fieldContext_Block_tx_count(ctx, field)
			case "txs":
				return ec.fieldContext_Block_txs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Block", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TxBlock_index(ctx context.Context, field graphql.CollectedField, obj *model.TxBlock) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TxBlock_index(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Index, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint32)
	fc.Result = res
	return ec.marshalNUint322uint32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TxBlock_index(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TxBlock",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint32 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TxInput_tx(ctx context.Context, field graphql.CollectedField, obj *model.TxInput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TxInput_tx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Tx)
	fc.Result = res
	return ec.marshalNTx2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTx(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TxInput_tx(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TxInput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hash":
				return ec.fieldContext_Tx_hash(ctx, field)
			case "raw":
				return ec.fieldContext_Tx_raw(ctx, field)
			case "inputs":
				return ec.fieldContext_Tx_inputs(ctx, field)
			case "outputs":
				return ec.fieldContext_Tx_outputs(ctx, field)
			case "blocks":
				return ec.fieldContext_Tx_blocks(ctx, field)
			case "seen":
				return ec.fieldContext_Tx_seen(ctx, field)
			case "version":
				return ec.fieldContext_Tx_version(ctx, field)
			case "locktime":
				return ec.fieldContext_Tx_locktime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tx", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TxInput_hash(ctx context.Context, field graphql.CollectedField, obj *model.TxInput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TxInput_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Hash)
	fc.Result = res
	return ec.marshalNHash2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐHash(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TxInput_hash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TxInput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Hash does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TxInput_index(ctx context.Context, field graphql.CollectedField, obj *model.TxInput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TxInput_index(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Index, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint32)
	fc.Result = res
	return ec.marshalNUint322uint32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TxInput_index(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TxInput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint32 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TxInput_script(ctx context.Context, field graphql.CollectedField, obj *model.TxInput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TxInput_script(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Script, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Bytes)
	fc.Result = res
	return ec.marshalNBytes2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐBytes(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TxInput_script(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TxInput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bytes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TxInput_prev_hash(ctx context.Context, field graphql.CollectedField, obj *model.TxInput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TxInput_prev_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrevHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Hash)
	fc.Result = res
	return ec.marshalNHash2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐHash(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TxInput_prev_hash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TxInput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Hash does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TxInput_prev_index(ctx context.Context, field graphql.CollectedField, obj *model.TxInput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TxInput_prev_index(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrevIndex, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint32)
	fc.Result = res
	return ec.marshalNUint322uint32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TxInput_prev_index(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TxInput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint32 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TxInput_output(ctx context.Context, field graphql.CollectedField, obj *model.TxInput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TxInput_output(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Output, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.TxOutput)
	fc.Result = res
	return ec.marshalOTxOutput2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTxOutput(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TxInput_output(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TxInput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tx":
				return ec.fieldContext_TxOutput_tx(ctx, field)
			case "hash":
				return ec.fieldContext_TxOutput_hash(ctx, field)
			case "index":
				return ec.fieldContext_TxOutput_index(ctx, field)
			case "amount":
				return ec.fieldContext_TxOutput_amount(ctx, field)
			case "script":
				return ec.fieldContext_TxOutput_script(ctx, field)
			case "spends":
				return ec.fieldContext_TxOutput_spends(ctx, field)
			case "slp":
				return ec.fieldContext_TxOutput_slp(ctx, field)
			case "slp_baton":
				return ec.fieldContext_TxOutput_slp_baton(ctx, field)
			case "lock":
				return ec.fieldContext_TxOutput_lock(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TxOutput", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TxInput_sequence(ctx context.Context, field graphql.CollectedField, obj *model.TxInput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TxInput_sequence(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sequence, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint32)
	fc.Result = res
	return ec.marshalNUint322uint32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TxInput_sequence(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TxInput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint32 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TxOutput_tx(ctx context.Context, field graphql.CollectedField, obj *model.TxOutput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TxOutput_tx(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tx, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Tx)
	fc.Result = res
	return ec.marshalNTx2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTx(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TxOutput_tx(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TxOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hash":
				return ec.fieldContext_Tx_hash(ctx, field)
			case "raw":
				return ec.fieldContext_Tx_raw(ctx, field)
			case "inputs":
				return ec.fieldContext_Tx_inputs(ctx, field)
			case "outputs":
				return ec.fieldContext_Tx_outputs(ctx, field)
			case "blocks":
				return ec.fieldContext_Tx_blocks(ctx, field)
			case "seen":
				return ec.fieldContext_Tx_seen(ctx, field)
			case "version":
				return ec.fieldContext_Tx_version(ctx, field)
			case "locktime":
				return ec.fieldContext_Tx_locktime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tx", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TxOutput_hash(ctx context.Context, field graphql.CollectedField, obj *model.TxOutput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TxOutput_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Hash)
	fc.Result = res
	return ec.marshalNHash2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐHash(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TxOutput_hash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TxOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Hash does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TxOutput_index(ctx context.Context, field graphql.CollectedField, obj *model.TxOutput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TxOutput_index(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Index, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint32)
	fc.Result = res
	return ec.marshalNUint322uint32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TxOutput_index(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TxOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Uint32 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TxOutput_amount(ctx context.Context, field graphql.CollectedField, obj *model.TxOutput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TxOutput_amount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Amount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt642int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TxOutput_amount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TxOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TxOutput_script(ctx context.Context, field graphql.CollectedField, obj *model.TxOutput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TxOutput_script(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Script, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.Bytes)
	fc.Result = res
	return ec.marshalNBytes2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐBytes(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TxOutput_script(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TxOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bytes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TxOutput_spends(ctx context.Context, field graphql.CollectedField, obj *model.TxOutput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TxOutput_spends(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Spends, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.TxInput)
	fc.Result = res
	return ec.marshalOTxInput2ᚕᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTxInput(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TxOutput_spends(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TxOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tx":
				return ec.fieldContext_TxInput_tx(ctx, field)
			case "hash":
				return ec.fieldContext_TxInput_hash(ctx, field)
			case "index":
				return ec.fieldContext_TxInput_index(ctx, field)
			case "script":
				return ec.fieldContext_TxInput_script(ctx, field)
			case "prev_hash":
				return ec.fieldContext_TxInput_prev_hash(ctx, field)
			case "prev_index":
				return ec.fieldContext_TxInput_prev_index(ctx, field)
			case "output":
				return ec.fieldContext_TxInput_output(ctx, field)
			case "sequence":
				return ec.fieldContext_TxInput_sequence(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TxInput", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TxOutput_slp(ctx context.Context, field graphql.CollectedField, obj *model.TxOutput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TxOutput_slp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Slp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.SlpOutput)
	fc.Result = res
	return ec.marshalOSlpOutput2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐSlpOutput(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TxOutput_slp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TxOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "output":
				return ec.fieldContext_SlpOutput_output(ctx, field)
			case "hash":
				return ec.fieldContext_SlpOutput_hash(ctx, field)
			case "index":
				return ec.fieldContext_SlpOutput_index(ctx, field)
			case "amount":
				return ec.fieldContext_SlpOutput_amount(ctx, field)
			case "token_hash":
				return ec.fieldContext_SlpOutput_token_hash(ctx, field)
			case "genesis":
				return ec.fieldContext_SlpOutput_genesis(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SlpOutput", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TxOutput_slp_baton(ctx context.Context, field graphql.CollectedField, obj *model.TxOutput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TxOutput_slp_baton(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SlpBaton, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.SlpBaton)
	fc.Result = res
	return ec.marshalOSlpBaton2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐSlpBaton(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TxOutput_slp_baton(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TxOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "output":
				return ec.fieldContext_SlpBaton_output(ctx, field)
			case "hash":
				return ec.fieldContext_SlpBaton_hash(ctx, field)
			case "index":
				return ec.fieldContext_SlpBaton_index(ctx, field)
			case "token_hash":
				return ec.fieldContext_SlpBaton_token_hash(ctx, field)
			case "genesis":
				return ec.fieldContext_SlpBaton_genesis(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SlpBaton", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TxOutput_lock(ctx context.Context, field graphql.CollectedField, obj *model.TxOutput) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TxOutput_lock(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lock, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Lock)
	fc.Result = res
	return ec.marshalOLock2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐLock(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TxOutput_lock(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TxOutput",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "address":
				return ec.fieldContext_Lock_address(ctx, field)
			case "profile":
				return ec.fieldContext_Lock_profile(ctx, field)
			case "txs":
				return ec.fieldContext_Lock_txs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Lock", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var blockImplementors = []string{"Block"}

func (ec *executionContext) _Block(ctx context.Context, sel ast.SelectionSet, obj *model.Block) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, blockImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Block")
		case "hash":

			out.Values[i] = ec._Block_hash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "raw":

			out.Values[i] = ec._Block_raw(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "timestamp":

			out.Values[i] = ec._Block_timestamp(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "height":

			out.Values[i] = ec._Block_height(ctx, field, obj)

		case "size":

			out.Values[i] = ec._Block_size(ctx, field, obj)

		case "tx_count":

			out.Values[i] = ec._Block_tx_count(ctx, field, obj)

		case "txs":

			out.Values[i] = ec._Block_txs(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var followImplementors = []string{"Follow"}

func (ec *executionContext) _Follow(ctx context.Context, sel ast.SelectionSet, obj *model.Follow) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, followImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Follow")
		case "tx":

			out.Values[i] = ec._Follow_tx(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "tx_hash":

			out.Values[i] = ec._Follow_tx_hash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "lock":

			out.Values[i] = ec._Follow_lock(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "address":

			out.Values[i] = ec._Follow_address(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "follow_lock":

			out.Values[i] = ec._Follow_follow_lock(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "follow_address":

			out.Values[i] = ec._Follow_follow_address(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "unfollow":

			out.Values[i] = ec._Follow_unfollow(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var likeImplementors = []string{"Like"}

func (ec *executionContext) _Like(ctx context.Context, sel ast.SelectionSet, obj *model.Like) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, likeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Like")
		case "tx":

			out.Values[i] = ec._Like_tx(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "tx_hash":

			out.Values[i] = ec._Like_tx_hash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "lock":

			out.Values[i] = ec._Like_lock(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "address":

			out.Values[i] = ec._Like_address(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "post_tx_hash":

			out.Values[i] = ec._Like_post_tx_hash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "post":

			out.Values[i] = ec._Like_post(ctx, field, obj)

		case "tip":

			out.Values[i] = ec._Like_tip(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var lockImplementors = []string{"Lock"}

func (ec *executionContext) _Lock(ctx context.Context, sel ast.SelectionSet, obj *model.Lock) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, lockImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Lock")
		case "address":

			out.Values[i] = ec._Lock_address(ctx, field, obj)

		case "profile":

			out.Values[i] = ec._Lock_profile(ctx, field, obj)

		case "txs":

			out.Values[i] = ec._Lock_txs(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "broadcast":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_broadcast(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var postImplementors = []string{"Post"}

func (ec *executionContext) _Post(ctx context.Context, sel ast.SelectionSet, obj *model.Post) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, postImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Post")
		case "tx":

			out.Values[i] = ec._Post_tx(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "tx_hash":

			out.Values[i] = ec._Post_tx_hash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "lock":

			out.Values[i] = ec._Post_lock(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "address":

			out.Values[i] = ec._Post_address(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "text":

			out.Values[i] = ec._Post_text(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "likes":

			out.Values[i] = ec._Post_likes(ctx, field, obj)

		case "parent":

			out.Values[i] = ec._Post_parent(ctx, field, obj)

		case "replies":

			out.Values[i] = ec._Post_replies(ctx, field, obj)

		case "room":

			out.Values[i] = ec._Post_room(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var profileImplementors = []string{"Profile"}

func (ec *executionContext) _Profile(ctx context.Context, sel ast.SelectionSet, obj *model.Profile) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, profileImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Profile")
		case "lock":

			out.Values[i] = ec._Profile_lock(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "address":

			out.Values[i] = ec._Profile_address(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._Profile_name(ctx, field, obj)

		case "profile":

			out.Values[i] = ec._Profile_profile(ctx, field, obj)

		case "pic":

			out.Values[i] = ec._Profile_pic(ctx, field, obj)

		case "following":

			out.Values[i] = ec._Profile_following(ctx, field, obj)

		case "followers":

			out.Values[i] = ec._Profile_followers(ctx, field, obj)

		case "posts":

			out.Values[i] = ec._Profile_posts(ctx, field, obj)

		case "rooms":

			out.Values[i] = ec._Profile_rooms(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "tx":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_tx(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "txs":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_txs(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "address":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_address(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "addresses":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_addresses(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "block":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_block(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "block_newest":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_block_newest(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "blocks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_blocks(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "profiles":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_profiles(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "posts":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_posts(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "posts_newest":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_posts_newest(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "room":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_room(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "__type":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})

		case "__schema":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var roomImplementors = []string{"Room"}

func (ec *executionContext) _Room(ctx context.Context, sel ast.SelectionSet, obj *model.Room) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, roomImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Room")
		case "name":

			out.Values[i] = ec._Room_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "posts":

			out.Values[i] = ec._Room_posts(ctx, field, obj)

		case "followers":

			out.Values[i] = ec._Room_followers(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var roomFollowImplementors = []string{"RoomFollow"}

func (ec *executionContext) _RoomFollow(ctx context.Context, sel ast.SelectionSet, obj *model.RoomFollow) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, roomFollowImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RoomFollow")
		case "name":

			out.Values[i] = ec._RoomFollow_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "room":

			out.Values[i] = ec._RoomFollow_room(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "lock":

			out.Values[i] = ec._RoomFollow_lock(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "address":

			out.Values[i] = ec._RoomFollow_address(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "unfollow":

			out.Values[i] = ec._RoomFollow_unfollow(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "tx_hash":

			out.Values[i] = ec._RoomFollow_tx_hash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "tx":

			out.Values[i] = ec._RoomFollow_tx(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var setNameImplementors = []string{"SetName"}

func (ec *executionContext) _SetName(ctx context.Context, sel ast.SelectionSet, obj *model.SetName) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, setNameImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SetName")
		case "tx":

			out.Values[i] = ec._SetName_tx(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "tx_hash":

			out.Values[i] = ec._SetName_tx_hash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "lock":

			out.Values[i] = ec._SetName_lock(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "address":

			out.Values[i] = ec._SetName_address(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._SetName_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var setPicImplementors = []string{"SetPic"}

func (ec *executionContext) _SetPic(ctx context.Context, sel ast.SelectionSet, obj *model.SetPic) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, setPicImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SetPic")
		case "tx":

			out.Values[i] = ec._SetPic_tx(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "tx_hash":

			out.Values[i] = ec._SetPic_tx_hash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "lock":

			out.Values[i] = ec._SetPic_lock(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "address":

			out.Values[i] = ec._SetPic_address(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "pic":

			out.Values[i] = ec._SetPic_pic(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var setProfileImplementors = []string{"SetProfile"}

func (ec *executionContext) _SetProfile(ctx context.Context, sel ast.SelectionSet, obj *model.SetProfile) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, setProfileImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SetProfile")
		case "tx":

			out.Values[i] = ec._SetProfile_tx(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "tx_hash":

			out.Values[i] = ec._SetProfile_tx_hash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "lock":

			out.Values[i] = ec._SetProfile_lock(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "address":

			out.Values[i] = ec._SetProfile_address(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "text":

			out.Values[i] = ec._SetProfile_text(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var slpBatonImplementors = []string{"SlpBaton"}

func (ec *executionContext) _SlpBaton(ctx context.Context, sel ast.SelectionSet, obj *model.SlpBaton) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, slpBatonImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SlpBaton")
		case "output":

			out.Values[i] = ec._SlpBaton_output(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "hash":

			out.Values[i] = ec._SlpBaton_hash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "index":

			out.Values[i] = ec._SlpBaton_index(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "token_hash":

			out.Values[i] = ec._SlpBaton_token_hash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "genesis":

			out.Values[i] = ec._SlpBaton_genesis(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var slpGenesisImplementors = []string{"SlpGenesis"}

func (ec *executionContext) _SlpGenesis(ctx context.Context, sel ast.SelectionSet, obj *model.SlpGenesis) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, slpGenesisImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SlpGenesis")
		case "tx":

			out.Values[i] = ec._SlpGenesis_tx(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "hash":

			out.Values[i] = ec._SlpGenesis_hash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "token_type":

			out.Values[i] = ec._SlpGenesis_token_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "decimals":

			out.Values[i] = ec._SlpGenesis_decimals(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "output":

			out.Values[i] = ec._SlpGenesis_output(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "baton":

			out.Values[i] = ec._SlpGenesis_baton(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "baton_index":

			out.Values[i] = ec._SlpGenesis_baton_index(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ticker":

			out.Values[i] = ec._SlpGenesis_ticker(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._SlpGenesis_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "doc_url":

			out.Values[i] = ec._SlpGenesis_doc_url(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "doc_hash":

			out.Values[i] = ec._SlpGenesis_doc_hash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var slpOutputImplementors = []string{"SlpOutput"}

func (ec *executionContext) _SlpOutput(ctx context.Context, sel ast.SelectionSet, obj *model.SlpOutput) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, slpOutputImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SlpOutput")
		case "output":

			out.Values[i] = ec._SlpOutput_output(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "hash":

			out.Values[i] = ec._SlpOutput_hash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "index":

			out.Values[i] = ec._SlpOutput_index(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "amount":

			out.Values[i] = ec._SlpOutput_amount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "token_hash":

			out.Values[i] = ec._SlpOutput_token_hash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "genesis":

			out.Values[i] = ec._SlpOutput_genesis(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var subscriptionImplementors = []string{"Subscription"}

func (ec *executionContext) _Subscription(ctx context.Context, sel ast.SelectionSet) func(ctx context.Context) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriptionImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Subscription",
	})
	if len(fields) != 1 {
		ec.Errorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	case "address":
		return ec._Subscription_address(ctx, fields[0])
	case "addresses":
		return ec._Subscription_addresses(ctx, fields[0])
	case "blocks":
		return ec._Subscription_blocks(ctx, fields[0])
	case "posts":
		return ec._Subscription_posts(ctx, fields[0])
	case "profiles":
		return ec._Subscription_profiles(ctx, fields[0])
	case "rooms":
		return ec._Subscription_rooms(ctx, fields[0])
	case "room_follows":
		return ec._Subscription_room_follows(ctx, fields[0])
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}

var txImplementors = []string{"Tx"}

func (ec *executionContext) _Tx(ctx context.Context, sel ast.SelectionSet, obj *model.Tx) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, txImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Tx")
		case "hash":

			out.Values[i] = ec._Tx_hash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "raw":

			out.Values[i] = ec._Tx_raw(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "inputs":

			out.Values[i] = ec._Tx_inputs(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "outputs":

			out.Values[i] = ec._Tx_outputs(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "blocks":

			out.Values[i] = ec._Tx_blocks(ctx, field, obj)

		case "seen":

			out.Values[i] = ec._Tx_seen(ctx, field, obj)

		case "version":

			out.Values[i] = ec._Tx_version(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "locktime":

			out.Values[i] = ec._Tx_locktime(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var txBlockImplementors = []string{"TxBlock"}

func (ec *executionContext) _TxBlock(ctx context.Context, sel ast.SelectionSet, obj *model.TxBlock) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, txBlockImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TxBlock")
		case "tx_hash":

			out.Values[i] = ec._TxBlock_tx_hash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "tx":

			out.Values[i] = ec._TxBlock_tx(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "block_hash":

			out.Values[i] = ec._TxBlock_block_hash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "block":

			out.Values[i] = ec._TxBlock_block(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "index":

			out.Values[i] = ec._TxBlock_index(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var txInputImplementors = []string{"TxInput"}

func (ec *executionContext) _TxInput(ctx context.Context, sel ast.SelectionSet, obj *model.TxInput) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, txInputImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TxInput")
		case "tx":

			out.Values[i] = ec._TxInput_tx(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "hash":

			out.Values[i] = ec._TxInput_hash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "index":

			out.Values[i] = ec._TxInput_index(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "script":

			out.Values[i] = ec._TxInput_script(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "prev_hash":

			out.Values[i] = ec._TxInput_prev_hash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "prev_index":

			out.Values[i] = ec._TxInput_prev_index(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "output":

			out.Values[i] = ec._TxInput_output(ctx, field, obj)

		case "sequence":

			out.Values[i] = ec._TxInput_sequence(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var txOutputImplementors = []string{"TxOutput"}

func (ec *executionContext) _TxOutput(ctx context.Context, sel ast.SelectionSet, obj *model.TxOutput) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, txOutputImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TxOutput")
		case "tx":

			out.Values[i] = ec._TxOutput_tx(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "hash":

			out.Values[i] = ec._TxOutput_hash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "index":

			out.Values[i] = ec._TxOutput_index(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "amount":

			out.Values[i] = ec._TxOutput_amount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "script":

			out.Values[i] = ec._TxOutput_script(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "spends":

			out.Values[i] = ec._TxOutput_spends(ctx, field, obj)

		case "slp":

			out.Values[i] = ec._TxOutput_slp(ctx, field, obj)

		case "slp_baton":

			out.Values[i] = ec._TxOutput_slp_baton(ctx, field, obj)

		case "lock":

			out.Values[i] = ec._TxOutput_lock(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":

			out.Values[i] = ec.___Directive_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Directive_description(ctx, field, obj)

		case "locations":

			out.Values[i] = ec.___Directive_locations(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":

			out.Values[i] = ec.___Directive_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRepeatable":

			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":

			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)

		case "isDeprecated":

			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":

			out.Values[i] = ec.___Field_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Field_description(ctx, field, obj)

		case "args":

			out.Values[i] = ec.___Field_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":

			out.Values[i] = ec.___Field_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":

			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":

			out.Values[i] = ec.___InputValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___InputValue_description(ctx, field, obj)

		case "type":

			out.Values[i] = ec.___InputValue_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":

			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":

			out.Values[i] = ec.___Schema_description(ctx, field, obj)

		case "types":

			out.Values[i] = ec.___Schema_types(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":

			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":

			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)

		case "subscriptionType":

			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)

		case "directives":

			out.Values[i] = ec.___Schema_directives(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":

			out.Values[i] = ec.___Type_kind(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec.___Type_name(ctx, field, obj)

		case "description":

			out.Values[i] = ec.___Type_description(ctx, field, obj)

		case "fields":

			out.Values[i] = ec.___Type_fields(ctx, field, obj)

		case "interfaces":

			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)

		case "possibleTypes":

			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)

		case "enumValues":

			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)

		case "inputFields":

			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)

		case "ofType":

			out.Values[i] = ec.___Type_ofType(ctx, field, obj)

		case "specifiedByURL":

			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNAddress2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐAddress(ctx context.Context, v interface{}) (model.Address, error) {
	res, err := model.UnmarshalAddress(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAddress2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐAddress(ctx context.Context, sel ast.SelectionSet, v model.Address) graphql.Marshaler {
	res := model.MarshalAddress(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNBlock2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐBlock(ctx context.Context, sel ast.SelectionSet, v *model.Block) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Block(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNBytes2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐBytes(ctx context.Context, v interface{}) (model.Bytes, error) {
	res, err := model.UnmarshalBytes(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBytes2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐBytes(ctx context.Context, sel ast.SelectionSet, v model.Bytes) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := model.MarshalBytes(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNDate2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐDate(ctx context.Context, v interface{}) (model.Date, error) {
	res, err := model.UnmarshalDate(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDate2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐDate(ctx context.Context, sel ast.SelectionSet, v model.Date) graphql.Marshaler {
	res := model.MarshalDate(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNHash2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐHash(ctx context.Context, v interface{}) (model.Hash, error) {
	res, err := model.UnmarshalHash(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNHash2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐHash(ctx context.Context, sel ast.SelectionSet, v model.Hash) graphql.Marshaler {
	res := model.MarshalHash(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt322int32(ctx context.Context, v interface{}) (int32, error) {
	res, err := graphql.UnmarshalInt32(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt322int32(ctx context.Context, sel ast.SelectionSet, v int32) graphql.Marshaler {
	res := graphql.MarshalInt32(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt642int64(ctx context.Context, v interface{}) (int64, error) {
	res, err := graphql.UnmarshalInt64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt642int64(ctx context.Context, sel ast.SelectionSet, v int64) graphql.Marshaler {
	res := graphql.MarshalInt64(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNLike2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐLike(ctx context.Context, sel ast.SelectionSet, v *model.Like) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Like(ctx, sel, v)
}

func (ec *executionContext) marshalNLock2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐLock(ctx context.Context, sel ast.SelectionSet, v *model.Lock) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Lock(ctx, sel, v)
}

func (ec *executionContext) marshalNPost2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐPost(ctx context.Context, sel ast.SelectionSet, v *model.Post) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Post(ctx, sel, v)
}

func (ec *executionContext) marshalNRoom2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐRoom(ctx context.Context, sel ast.SelectionSet, v model.Room) graphql.Marshaler {
	return ec._Room(ctx, sel, &v)
}

func (ec *executionContext) marshalNRoom2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐRoom(ctx context.Context, sel ast.SelectionSet, v *model.Room) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Room(ctx, sel, v)
}

func (ec *executionContext) marshalNRoomFollow2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐRoomFollow(ctx context.Context, sel ast.SelectionSet, v *model.RoomFollow) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RoomFollow(ctx, sel, v)
}

func (ec *executionContext) marshalNSlpBaton2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐSlpBaton(ctx context.Context, sel ast.SelectionSet, v *model.SlpBaton) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SlpBaton(ctx, sel, v)
}

func (ec *executionContext) marshalNSlpOutput2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐSlpOutput(ctx context.Context, sel ast.SelectionSet, v *model.SlpOutput) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SlpOutput(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNTx2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTx(ctx context.Context, sel ast.SelectionSet, v *model.Tx) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Tx(ctx, sel, v)
}

func (ec *executionContext) marshalNTxBlock2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTxBlock(ctx context.Context, sel ast.SelectionSet, v *model.TxBlock) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TxBlock(ctx, sel, v)
}

func (ec *executionContext) marshalNTxInput2ᚕᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTxInputᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.TxInput) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTxInput2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTxInput(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTxInput2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTxInput(ctx context.Context, sel ast.SelectionSet, v *model.TxInput) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TxInput(ctx, sel, v)
}

func (ec *executionContext) marshalNTxOutput2ᚕᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTxOutputᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.TxOutput) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTxOutput2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTxOutput(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTxOutput2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTxOutput(ctx context.Context, sel ast.SelectionSet, v *model.TxOutput) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TxOutput(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUint322uint32(ctx context.Context, v interface{}) (uint32, error) {
	res, err := graphql.UnmarshalUint32(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUint322uint32(ctx context.Context, sel ast.SelectionSet, v uint32) graphql.Marshaler {
	res := graphql.MarshalUint32(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNUint642uint64(ctx context.Context, v interface{}) (uint64, error) {
	res, err := graphql.UnmarshalUint64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUint642uint64(ctx context.Context, sel ast.SelectionSet, v uint64) graphql.Marshaler {
	res := graphql.MarshalUint64(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNUint82githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐUint8(ctx context.Context, v interface{}) (model.Uint8, error) {
	res, err := model.UnmarshalUint8(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUint82githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐUint8(ctx context.Context, sel ast.SelectionSet, v model.Uint8) graphql.Marshaler {
	res := model.MarshalUint8(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOAddress2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐAddress(ctx context.Context, v interface{}) (model.Address, error) {
	res, err := model.UnmarshalAddress(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAddress2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐAddress(ctx context.Context, sel ast.SelectionSet, v model.Address) graphql.Marshaler {
	res := model.MarshalAddress(v)
	return res
}

func (ec *executionContext) unmarshalOAddress2ᚕgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐAddressᚄ(ctx context.Context, v interface{}) ([]model.Address, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.Address, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAddress2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐAddress(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOAddress2ᚕgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐAddressᚄ(ctx context.Context, sel ast.SelectionSet, v []model.Address) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNAddress2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐAddress(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOBlock2ᚕᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐBlockᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Block) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBlock2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐBlock(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOBlock2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐBlock(ctx context.Context, sel ast.SelectionSet, v *model.Block) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Block(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalODate2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐDate(ctx context.Context, v interface{}) (model.Date, error) {
	res, err := model.UnmarshalDate(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODate2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐDate(ctx context.Context, sel ast.SelectionSet, v model.Date) graphql.Marshaler {
	res := model.MarshalDate(v)
	return res
}

func (ec *executionContext) unmarshalODate2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐDate(ctx context.Context, v interface{}) (*model.Date, error) {
	if v == nil {
		return nil, nil
	}
	res, err := model.UnmarshalDate(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODate2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐDate(ctx context.Context, sel ast.SelectionSet, v *model.Date) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := model.MarshalDate(*v)
	return res
}

func (ec *executionContext) marshalOFollow2ᚕᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐFollow(ctx context.Context, sel ast.SelectionSet, v []*model.Follow) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOFollow2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐFollow(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOFollow2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐFollow(ctx context.Context, sel ast.SelectionSet, v *model.Follow) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Follow(ctx, sel, v)
}

func (ec *executionContext) unmarshalOHash2ᚕgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐHashᚄ(ctx context.Context, v interface{}) ([]model.Hash, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.Hash, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNHash2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐHash(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOHash2ᚕgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐHashᚄ(ctx context.Context, sel ast.SelectionSet, v []model.Hash) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNHash2githubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐHash(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOHash2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐHash(ctx context.Context, v interface{}) (*model.Hash, error) {
	if v == nil {
		return nil, nil
	}
	res, err := model.UnmarshalHash(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOHash2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐHash(ctx context.Context, sel ast.SelectionSet, v *model.Hash) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := model.MarshalHash(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	return res
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) unmarshalOInt642int64(ctx context.Context, v interface{}) (int64, error) {
	res, err := graphql.UnmarshalInt64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt642int64(ctx context.Context, sel ast.SelectionSet, v int64) graphql.Marshaler {
	res := graphql.MarshalInt64(v)
	return res
}

func (ec *executionContext) marshalOLike2ᚕᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐLikeᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Like) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLike2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐLike(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOLock2ᚕᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐLock(ctx context.Context, sel ast.SelectionSet, v []*model.Lock) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOLock2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐLock(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOLock2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐLock(ctx context.Context, sel ast.SelectionSet, v *model.Lock) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Lock(ctx, sel, v)
}

func (ec *executionContext) marshalOPost2ᚕᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐPost(ctx context.Context, sel ast.SelectionSet, v []*model.Post) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOPost2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐPost(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOPost2ᚕᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐPostᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Post) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPost2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐPost(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOPost2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐPost(ctx context.Context, sel ast.SelectionSet, v *model.Post) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Post(ctx, sel, v)
}

func (ec *executionContext) marshalOProfile2ᚕᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐProfile(ctx context.Context, sel ast.SelectionSet, v []*model.Profile) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOProfile2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐProfile(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOProfile2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐProfile(ctx context.Context, sel ast.SelectionSet, v *model.Profile) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Profile(ctx, sel, v)
}

func (ec *executionContext) marshalORoom2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐRoom(ctx context.Context, sel ast.SelectionSet, v *model.Room) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Room(ctx, sel, v)
}

func (ec *executionContext) marshalORoomFollow2ᚕᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐRoomFollowᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.RoomFollow) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRoomFollow2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐRoomFollow(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalORoomFollow2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐRoomFollow(ctx context.Context, sel ast.SelectionSet, v *model.RoomFollow) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RoomFollow(ctx, sel, v)
}

func (ec *executionContext) marshalOSetName2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐSetName(ctx context.Context, sel ast.SelectionSet, v *model.SetName) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SetName(ctx, sel, v)
}

func (ec *executionContext) marshalOSetPic2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐSetPic(ctx context.Context, sel ast.SelectionSet, v *model.SetPic) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SetPic(ctx, sel, v)
}

func (ec *executionContext) marshalOSetProfile2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐSetProfile(ctx context.Context, sel ast.SelectionSet, v *model.SetProfile) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SetProfile(ctx, sel, v)
}

func (ec *executionContext) marshalOSlpBaton2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐSlpBaton(ctx context.Context, sel ast.SelectionSet, v *model.SlpBaton) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SlpBaton(ctx, sel, v)
}

func (ec *executionContext) marshalOSlpGenesis2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐSlpGenesis(ctx context.Context, sel ast.SelectionSet, v *model.SlpGenesis) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SlpGenesis(ctx, sel, v)
}

func (ec *executionContext) marshalOSlpOutput2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐSlpOutput(ctx context.Context, sel ast.SelectionSet, v *model.SlpOutput) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SlpOutput(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOTx2ᚕᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTx(ctx context.Context, sel ast.SelectionSet, v []*model.Tx) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTx2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTx(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOTx2ᚕᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTxᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Tx) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTx2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTx(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOTx2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTx(ctx context.Context, sel ast.SelectionSet, v *model.Tx) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Tx(ctx, sel, v)
}

func (ec *executionContext) marshalOTxBlock2ᚕᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTxBlock(ctx context.Context, sel ast.SelectionSet, v []*model.TxBlock) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTxBlock2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTxBlock(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOTxBlock2ᚕᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTxBlockᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.TxBlock) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTxBlock2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTxBlock(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOTxBlock2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTxBlock(ctx context.Context, sel ast.SelectionSet, v *model.TxBlock) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TxBlock(ctx, sel, v)
}

func (ec *executionContext) marshalOTxInput2ᚕᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTxInput(ctx context.Context, sel ast.SelectionSet, v []*model.TxInput) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTxInput2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTxInput(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOTxInput2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTxInput(ctx context.Context, sel ast.SelectionSet, v *model.TxInput) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TxInput(ctx, sel, v)
}

func (ec *executionContext) marshalOTxOutput2ᚖgithubᚗcomᚋmemocashᚋindexᚋgraphᚋmodelᚐTxOutput(ctx context.Context, sel ast.SelectionSet, v *model.TxOutput) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TxOutput(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUint322ᚖuint32(ctx context.Context, v interface{}) (*uint32, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalUint32(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUint322ᚖuint32(ctx context.Context, sel ast.SelectionSet, v *uint32) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalUint32(*v)
	return res
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
